# 八股文-6

## GPM相关

### 1.进程、线程、协程有什么区别？（必问）

| 概念                  | 简述                                                     |
| --------------------- | -------------------------------------------------------- |
| **进程**（Process）   | 程序运行的实例，**资源的最小单位**，彼此**完全独立**     |
| **线程**（Thread）    | CPU 调度的最小单位，同一进程下的线程**共享资源**         |
| **协程**（Coroutine） | 用户态中的**轻量级线程**，由程序**自行调度切换**，更高效 |

补充：

进程，线程：操作系统内核调度		协程：用户程序中的协程调度器

线程：共享内存 / 同步原语 实现通信	协程：通常用 channel、函数调用等

**在 Go 中，goroutine 是语言级协程的实现，它相比线程更加轻量，启动成本只有几 KB，数以万计的 goroutine 也不会轻易拖垮系统，并由 Go runtime 的调度器（GMP 模型）自动管理和调度。**

### 2.什么是 GMP？（必问）

**GMP 是 Go 语言调度器的核心模型**，即：

- `G`（Goroutine）：Go 协程，代表可执行的任务；
- `M`（Machine）：内核线程，负责执行任务；
- `P`（Processor）：调度器上下文，维护本地的 G 队列并驱动调度逻辑。

Go 语言通过 GMP 模型实现了**高效的协程调度机制**，使得成千上万的 goroutine 可以被少量线程高效管理。

#### 调度流程详解：

1. 创建 Goroutine

   - 当调用 `go func()` 创建 goroutine 时，新的 `G` 会被加入当前 `P` 的 **本地队列**。

   - 若本地队列满了（默认最多 256 个 G），新的 G 会进入 **全局队列**。

2. 执行 Goroutine

   - 每个 `M` 必须先绑定一个 `P` 才能运行。

   - `M` 会从 `P` 的本地队列中获取 `G` 来执行。

   - 若本地队列为空：
     - 会优先从其他 `P` 的本地队列中**偷取一半 G（work stealing）**。
     - 最好尝试从 **全局队列**中获取；

   ```pgsql
   M + P => 运行 G
           ↓
      P 有本地队列 => 先从这里取 G
           ↓
      没有 G？→ Work stealing
           ↓
      还没有？→ Global G 队列取 G
           ↓
      还是没有？→ 解绑 M，P 给其他线程用
   ```

3. 系统调用 & 阻塞

   - 如果 G 在执行中发生阻塞（如 IO、锁等待），其绑定的 `M` 也会阻塞。

   - 此时 `P` 会被解绑，并移交给其他可用的 `M` 或新建一个 `M` 来继续工作（**hand off 机制**）。

   - 阻塞解除后，原来的 `M` 会尝试重新绑定空闲的 `P`。

#### G、M、P 的数量控制

| 名称               | 数量特性                                  | 限制说明                           |
| ------------------ | ----------------------------------------- | ---------------------------------- |
| **G（Goroutine）** | 理论无限                                  | 轻量，默认 2 KB 栈空间，受内存限制 |
| **P（Processor）** | 默认 = CPU 核心数，可由 `GOMAXPROCS` 设置 | 决定能并发运行多少个 G             |
| **M（Thread）**    | 动态分配（上限约 10K）                    | 多个 M 可绑定同一个 P，空闲时回收  |

#### 核心机制

| 机制              | 说明                                              |
| ----------------- | ------------------------------------------------- |
| **Work Stealing** | G 从其他 P 的本地队列中“偷取”任务以维持负载均衡。 |
| **Hand Off**      | 当 M 阻塞时，会释放 P，P 会移交给其他可用 M。     |

在高并发服务场景下，GMP 机制通过 Work Stealing 和 Hand Off 保证了 goroutine 的高效调度与最小开销，使得 Go 在高并发编程中具有明显优势。

### 3.为什么要有 P？

| 原因               | 说明                                   |
| ------------------ | -------------------------------------- |
| 减少锁竞争         | 本地队列 → 多数调度不走全局锁          |
| 限制并发核心       | GOMAXPROCS 控制最大并发                |
| 高效 work stealing | 从有限个 P 中偷任务更快                |
| 解耦线程阻塞       | M 阻塞时 P 可移交，不拖累调度          |
| 更强可控性         | 相比线程，P 是 Go 运行时自己控制的资源 |

解释：**为什么 Go 要引入 P？（为什么不能直接挂在 M 上？）**

Go 想要实现一个：

- **高并发、高吞吐**的调度系统；
- **最小化锁竞争**（Global Queue 上的争抢）；
- **可控数量的调度器资源**（避免资源无限扩张）；
- 能适应 **阻塞操作** 的现实情况（比如网络 I/O）。

------

#### **M 上挂本地队列会出什么问题？**

1. **线程数不可控，容易“爆炸”**   
   - M 的数量是**动态变化**的，系统调用一多、阻塞一多，线程就多。
   - 如果每个 M 都有一个本地队列，那本地队列的数量也就不可控。
   - 很容易造成 **调度状态不统一、资源浪费**、甚至性能下降。
2. **Work Stealing 变慢了**
   - 本地队列太多会导致 work stealing 的效率下降，**因为你得多找“邻居”偷任务**，而不是从固定的几个地方偷。
   - 更严重的是你可能“偷不到活干”，于是 CPU 资源就闲着了。
3. **M 是系统资源，不好控制调度粒度** 
   - M 是底层线程，由系统调度控制；如果我们把任务队列直接挂载在它身上，调度的灵活性和优化空间就变小了。

####  **引入 P：灵活控制“调度资源”**

​	所以 Go 引入了 P（Processor），**作为“调度器上下文”**的核心，主要解决两件事：

1. ✅ **固定调度核心数量**
   - 通过 `GOMAXPROCS` 明确设置：同时“活跃”的 P 不超过这个数，确保不会滥用 CPU。
   - 控制粒度变成可控的 N 个 “调度核心”。
2. ✅ **每个 P 有一个本地队列**
   - 锁竞争减少：大部分 `G` 的调度都发生在 P 本地，减少全局队列的访问。
   - 更高效的 Work Stealing：只有从这少数几个 P 中偷任务，快得多。
3. ✅ **当 M 阻塞，P 可脱离**
   - 如果 M 因系统调用被阻塞，P 会解绑，交给另一个空闲的 M 继续干活。
   - **最大程度利用 P 本地队列上的任务，不浪费时间资源。**



### 4.调度器的设计策略

| 策略                         | 作用                                          |
| ---------------------------- | --------------------------------------------- |
| **线程复用**                 | 减少线程频繁创建/销毁，提高资源利用率         |
| **并行利用**                 | 精细控制最大并发核心数量，提升多核利用率      |
| **抢占机制**                 | 防止某些 goroutine 长时间占用 CPU，提升公平性 |
| **本地队列 + work stealing** | 缓解锁竞争，提高调度效率                      |

**线程复用：资源高效使用**

- **复用 M（线程）**：Go 不轻易创建新线程，优先从线程池中复用已有的 M。
- **配合 handoff 和 work stealing 实现非阻塞运行**

🔧 **细节机制**：

- `hand off`：M 阻塞时主动释放 P，其他空闲 M 可以继续接手 P。
- `work stealing`：P 的本地队列为空，就去偷别人的 G，而不是挂起 M 或退出线程。

------

**并行利用：GOMAXPROCS 控制调度核心数**

- 每个 `P` 代表一个“调度核心”。
- 设置 `GOMAXPROCS = N`，最多同时运行 N 个 goroutine。
- 线程（M）会被绑定到 `P` 上运行，而不是无限制创建。

🧩 通过控制 `P` 数量，既避免了 CPU 占用过多，又能利用多核并行，**精细化控制并发程度**。

------

 **抢占式调度：防止“饿死”**

> Go1.14+改版了，这里详见5.

- Go 是“**协作 + 抢占式**”调度的混合体。
- **协作式**：Goroutine 主动让出 CPU。
- **抢占式**：Go 运行时会定期插入中断检查点，每个 goroutine 最多运行 10ms，超过就会被抢占，切换到其他 goroutine。

📌 解决传统 coroutine 依赖协作让出 CPU 的弊端，提高公平性，避免长时间占用。

------

**弱化的全局 G 队列：补充调度来源**

- 每个 P 有自己的 **本地队列**，大多数情况下调度从本地队列获取 G。
- **只有当偷不到 G 且本地队列空了，才从全局队列中获取 G。**

📉 减少对全局队列的依赖 → **锁竞争大幅降低**，提高调度性能。



### 5.**抢占式调度是如何抢占的？**

**Go 抢占式调度机制详解：两种核心方式**

（1）协作式抢占（Cooperative Preemption）

原理：

- goroutine 在执行过程中，**主动进入“安全点（safe-point）”**。
- runtime 在这些点上 **检测是否有调度请求（例如：GOMAXPROCS 限制了当前可运行 G 的数量）**。
- 如果需要被抢占，就在此点让出 CPU。

 常见的“安全点”：**函数调用** ，channel 操作，`select`，`runtime.Gosched()`，`goexit()`，栈检查（stack check）

局限性：如果 goroutine 运行的是长时间的计算逻辑、死循环，**中间没有“安全点”**，那么它不会被打断，就会“饿死”其他 G。

------

（2）基于信号的异步抢占（Asynchronous Preemption）

> Go 1.14 后引入的“真正的抢占式调度”，更接近 OS 的做法

原理：

- **runtime 每隔一段时间（默认 10ms）会通过 `sysmon` 线程向其他线程发送 SIGURG 信号**。
- 当前正在运行 G 被中断，Go runtime **修改其元数据（比如 `g.preempt = true`）**。
- 下次这个 G 进入函数调用或检查栈空间时，就会被迫抢占，切换到别的 G。

特点：

- 不再依赖 goroutine 自愿进入“安全点”，**只要你不配合，也会被信号打断！**
- 避免某个 G 长时间占用 CPU。

技术细节：实际是为每个栈帧打上 preempt 标志，当发生栈检查（stack grow check）时，触发强制调度。

> 栈检查通常在函数调用入口，系统会插入指令检查是否需要抢占（`checkPreempt`）。



### 6.调度器的生命周期

**M0（主线程）：**程序启动时由 OS 创建的 **第一个线程**。

- **作用：**
  - 初始化 runtime（如内存分配器、调度器、GC 等）
  - 启动第一个 goroutine（即 `runtime.main`）
  - 启动调度器循环
- **之后：** 初始化后，M0 就变成一个普通的 M，可以执行其他 G。

>  在 cgo 场景下，只有 M0 是可以安全地执行 `main.main` 

 **G0（调度专用 goroutine） ：** 每个 M 都有一个对应的 G0（所以**不是全局唯一**！）。

- **作用：**
  - 不执行用户代码，只用于 **调度和系统调用**。
  - 使用自己的栈来执行 `runtime.schedule()`、`runtime.newstack()` 等 runtime 相关代码。
- **特殊点：**
  - 不会出现在全局 G 队列或 P 的本地队列中。
  - M 切换 G 时，必须先切到 G0，用 G0 栈完成“调度准备”。

**`main`执行--》调度器启动流程：**

```go
🔧 创建 M0 + G0       → runtime.rt0_go
🏗️ 初始化调度器        → schedinit, P 列表
🌱 创建 main goroutine → runtime.main
🚀 M0 绑定 P 执行 G    → 切换栈 & 启动 main.main
🌅 程序运行/退出        → defer + panic + runtime.exit
```





## 锁相关

### 1.除了 `Mutex`，安全读写共享变量的方式？

| 方式            | 适用场景             | 特点简述                     |
| --------------- | -------------------- | ---------------------------- |
| `Mutex`         | 一般互斥访问         | 简单直接，适用于多种并发读写 |
| `RWMutex`       | 读多写少             | 读共享写独占，性能优于Mutex  |
| `atomic`        | 简单数值、高频操作   | 无锁高性能，只支持特定类型   |
| `channel`       | 协程间通信、避免共享 | 典型 Go 风格，解耦但性能略低 |
| `semaphore`     | 控制资源访问数量     | 模拟互斥或限制并发访问       |
| ~~`sync.Once`~~ | 只执行一次           | 懒加载/单例初始化            |

#### channel 通信实现共享内存

```go
type op struct {
    key   string
    value string
    reply chan string
}

func dataManager(opCh chan op) {
    store := make(map[string]string)
    for o := range opCh {
        if o.value != "" {
            store[o.key] = o.value
            o.reply <- "OK"
        } else {
            o.reply <- store[o.key]
        }
    }
}

```

#### **信号量（Semaphore）控制访问权**（本质是一种计数器）

> Go 中可以用 `sync.WaitGroup` + channel/第三方库模拟信号量，或者自己封装

```go
sem := make(chan struct{}, 1) // 信号量容量为1，等同于互斥

// 请求访问
sem <- struct{}{}
// 访问共享变量
shared++
// 释放访问
<-sem
```

####  **`sync/atomic` 原子操作包**（适用于基础类型）

```go
var counter int64

atomic.AddInt64(&counter, 1)
val := atomic.LoadInt64(&counter)
```

### 2.Go 如何实现原子操作？

答：原子操作（Atomic Operation）是一种**不可中断、不可分割的操作**，即操作在执行期间不会被其他 goroutine 或线程干扰。外部要么看到操作还没开始，要么看到操作已经完成，**中间状态是不可见的**。

Go 语言通过标准库中的 `sync/atomic` 包实现了原子操作，主要用于并发环境下**对基础类型变量的安全读写**，常用于计数器、标志位等场景。

| 操作类型 | 函数示例                                   | 说明                 |
| -------- | ------------------------------------------ | -------------------- |
| 读取     | `atomic.LoadInt64(&x)`                     | 原子读取变量         |
| 写入     | `atomic.StoreInt64(&x, v)`                 | 原子写入变量         |
| 加减     | `atomic.AddInt64(&x, 1)`                   | 原子加减，返回新值   |
| 交换     | `atomic.SwapInt64(&x, v)`                  | 原子交换，返回旧值   |
| CAS      | `atomic.CompareAndSwapInt64(&x, old, new)` | 比较并交换（原子性） |

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

var counter int64

func main() {
    var wg sync.WaitGroup

    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            atomic.AddInt64(&counter, 1) // 原子自增
            wg.Done()
        }()
    }

    wg.Wait()
    fmt.Println("Final Counter:", counter) // 输出 1000
}
//如果这里不用 atomic，而是直接 counter++，就会因为竞态条件导致最终结果远小于 1000！
```



### 3.Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？

#### Mutex 是悲观锁还是乐观锁？

答：**Mutex（互斥锁）属于悲观锁。**

| 项目     | 悲观锁（Pessimistic Lock）                | 乐观锁（Optimistic Lock）                                  |
| -------- | ----------------------------------------- | ---------------------------------------------------------- |
| 核心思想 | **先上锁再操作**，假设一定会发生冲突      | **先操作再检查**，假设大多数情况不会发生冲突               |
| 加锁时机 | **在读或写数据前就加锁**                  | **在写入数据时再验证是否有冲突**（通常通过版本号或时间戳） |
| 实现方式 | 数据库锁、`sync.Mutex`、`sync.RWMutex` 等 | CAS（Compare And Swap）+ 版本号/时间戳 + 原子操作          |
| 使用场景 | **写多读少**、冲突概率高的场景            | **读多写少**、冲突概率低的场景                             |

#### 乐观锁:

Go 中的乐观锁实现并不依赖标准库的锁结构，而是使用 `sync/atomic` 实现 **CAS（Compare-And-Swap）**

```go
package main

import (
	"fmt"
	"sync/atomic"
)

func main() {
	var value int64 = 100
	old := value
	new := old + 10

	if atomic.CompareAndSwapInt64(&value, old, new) {
		fmt.Println("更新成功：", value)
	} else {
		fmt.Println("更新失败，需要重试")
	}
}
```



### 4.sync.Mutex有几种模式？

| 模式         | 特点                  | 谁能获取锁                                               | 适用场景          |
| ------------ | --------------------- | -------------------------------------------------------- | ----------------- |
| **正常模式** | 自旋 + FIFO 队列      | CPU 上运行的新来的 goroutine + FIFO 队列里的老 goroutine | 普通并发，低冲突  |
| **饥饿模式** | 纯 FIFO，严格队列顺序 | 只允许队头的 goroutine 获取锁，新来的只能排队            | 高并发 + 饥饿风险 |

**正常模式：**

1. **无竞争情况：**

   - 如果没有其它 goroutine 持有锁，那就直接获取

2. **有竞争：**

   - 已有 goroutine 持有锁，新来的 goroutine 会：

     - 先 **自旋一会儿**（短暂原地等待，看能不能很快拿到锁）
     - 如果自旋失败，会被挂入一个**先进先出的 waiters 队列**

   - **锁释放时，会唤醒一个 waiter，但这个 waiter 不一定立刻能获取锁，因为新来的 goroutine 也会参与竞争！**

     > waiter等待1ms，如果没有获得锁，进入**饥饿 **模式
     
     这样可能导致 **waiter 被唤醒却又竞争失败，陷入长时间等待**，产生饥饿现象。

**饥饿模式：**

当**某个 waiter 超过 1ms 没抢到锁**时，Go 会认为竞争太激烈了，存在饥饿风险，就会触发“饥饿模式”：

- 不再允许新来的 goroutine 抢锁，**只让 waiters 队列的最前一个获取锁**
- **新来的 goroutine 会被安静地排到队列尾部，**不再尝试自旋或竞争



### 5.`sync.Mutex`

什么是 sync.Mutex？

`sync.Mutex` 是 Go 语言标准库 `sync` 包中的一种**互斥锁**类型。它用于在**多个 goroutine 并发访问共享资源**时，确保**同一时刻只有一个 goroutine 能访问资源**，从而避免**数据竞争**和**数据不一致**的问题。

------

sync.Mutex 的特点

1. **互斥性（Mutual Exclusion）**

- 在任意时间点，**只有一个** goroutine 可以持有锁。
- 如果锁已经被其他 goroutine 持有，新的 goroutine 会**阻塞等待**，直到锁被释放。

2. **非重入性（Not Reentrant）**

- 一个 goroutine **不能**重复加锁自己已经持有的 `sync.Mutex`。
- 如果尝试这样做，会因为自己阻塞自己，导致**死锁（Deadlock）**。

****

| 方法名     | 作用                                                         |
| :--------- | :----------------------------------------------------------- |
| `Lock()`   | 获取锁。如果锁已经被持有，则当前 goroutine 会阻塞等待。      |
| `Unlock()` | 释放锁。调用前必须保证当前 goroutine 已持有锁，否则会 panic。 |

> **补充：4.sync.Mutex 的两种模式**
>
> 在高并发环境下，Go 的 `sync.Mutex` 有**两种工作模式**哦！
>
> 1. **正常模式（Normal Mode）**
>    - goroutine 正常排队，自旋短时间后获取锁。
>    - 适用于**竞争不激烈**的情况。
> 2. **饥饿模式（Starvation Mode）**
>    - 如果等待超过一定时间（大约 1ms），就切换到饥饿模式。
>    - 锁会直接交给等待最久的 goroutine，**新来的 goroutine 不能抢锁**。
>    - 适用于**高竞争场景**，防止某些 goroutine 饿死（永远得不到锁）。



### 6.sync.RWMutex

💡什么是 sync.RWMutex？

`sync.RWMutex` 是 Go 语言标准库 `sync` 包里的**读写互斥锁（Reader-Writer Mutex）**。
相比普通的 `sync.Mutex`，它不仅可以加**写锁**，还可以加**读锁**，并且支持**多个读操作同时进行**！

------

✨sync.RWMutex 的特点

1. **多个读者，单一写者**

   - **多个读操作可以同时进行**，互不影响，提升了并发性能。

   - **写操作必须独占锁**，执行写操作时，禁止任何读写。

2. **优化读性能**
   - 在**读多写少**的场景下，可以让程序同时处理很多读请求，大大提高效率！

3. **写操作的独占性**
   - 写的时候必须锁定资源，防止在更新数据时被其他读操作「看见中间状态」，保证数据一致性。

------

🎈sync.RWMutex 提供的方法

| 方法名      | 作用                                               |
| :---------- | :------------------------------------------------- |
| `Lock()`    | 加写锁。阻塞直到获得独占访问权限。                 |
| `Unlock()`  | 释放写锁。必须和 `Lock()` 配对使用。               |
| `RLock()`   | 加读锁。如果没有写锁持有，可以立即加锁；否则等待。 |
| `RUnlock()` | 释放读锁。必须和 `RLock()` 配对使用。              |



> **总结：**
>
> | 特性     | sync.Mutex               | sync.RWMutex                                           |
> | :------- | :----------------------- | :----------------------------------------------------- |
> | 加锁方式 | 只有一个 Lock()          | 有 Lock() 写锁 + RLock() 读锁                          |
> | 并发能力 | 一次只允许一个 goroutine | 允许多个读 goroutine 可同时进行，只允许一个写goroutine |
> | 适用场景 | 读写比例差不多           | 读多写少                                               |



### 7. 自旋锁

<font style="color:#DF2A3F;">自旋锁是指当一个线程（在 Go 中是 Goroutine）在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待（自旋），不断判断锁是否已经被释放，而不是进入睡眠状态</font>。这种行为在某些情况下可能会导致资源的过度占用，特别是当锁持有时间较长或者自旋的 Goroutine 数量较多时。

自旋锁的**<font style="color:#DF2A3F;">核心思想</font>**是，如果预期锁很快就会被释放（即锁持有时间很短），那么**让线程持续运行并检查锁的状态，而不是进入睡眠和唤醒的昂贵操作**，可能会更加高效。然而，如果锁被长时间持有，或者多个线程同时竞争锁，**自旋锁可能会导致大量的CPU时间被浪费在无效的循环等待**

在Go语言中，虽然**标准库中没有直接提供自旋锁的实现**，但开发者可以**<font style="color:#DF2A3F;">通过原子操作</font>**和其他同步原语来实现自定义的自旋锁。然而，由于自旋锁可能导致CPU资源的过度占用，因此在决定使用自旋锁之前，应该仔细考虑其适用性和潜在的性能影响。在许多情况下，使用互斥锁或其他更高级的同步机制可能是更好的选择。

| 自旋锁特点   | 适合场景           | 注意事项               |
| :----------- | :----------------- | :--------------------- |
| 快速但耗 CPU | 短时间加锁，竞争低 | 自旋时间太长会浪费资源 |

### 8.如何实现自旋锁？

1. 用一个字段 `locked`（`int32` 类型），表示当前锁的状态：

   - `0`：没有被占用（空闲）；
   - `1`：已经被占用（有人拿着）。

2. 用 **原子操作** `atomic.CompareAndSwapInt32`（简称 CAS）来抢锁：

   > `atomic.CompareAndSwapInt32(&s.locked, 0, 1)`:
   >
   > **如果 locked 是 0，我就原子性地改成 1，否则啥也不干**

   - 成功：表示我抢到了，就可以继续干活了！
   - 失败：表示别人已经抢到了，那我就原地打转转继续抢！

3. 解锁时，用 `atomic.StoreInt32` 把 `locked` 设回 `0`，表示释放锁。

```go
package main

import (
	"sync/atomic"
	"time"
)

type Spinlock struct {
	locked int32
}

func (s *Spinlock) Lock() {
	for !atomic.CompareAndSwapInt32(&s.locked, 0, 1) {
		// ❗这里是打转转的地方
		// 可选：适当让出CPU，或者稍微sleep，防止CPU燃烧～
		// time.Sleep(time.Nanosecond)
	}
}

func (s *Spinlock) Unlock() {
	atomic.StoreInt32(&s.locked, 0)
}

func main() {
	var lock Spinlock

	go func() {
		lock.Lock()
		// ✨拿到锁，安全地做一些事情
		defer lock.Unlock()

		// 假装这里是重要的工作
		time.Sleep(100 * time.Millisecond)
	}()

	go func() {
		lock.Lock()
		defer lock.Unlock()

		time.Sleep(100 * time.Millisecond)
	}()

	// 主程序等待一下，别让子 goroutine 直接结束
	time.Sleep(time.Second)
}
```

### 9.自定义的自旋锁什么时候更改会失败？

1. **锁已被别人拿走了**

- 当你想改 `locked` 从 `0 ➔ 1` 时，

- 结果发现，啊呀！`locked` 其实已经是 `1` 啦～

- 说明别人正在用这个锁呢，不是空的，所以**不能随便改**。

  于是 `atomic.CompareAndSwapInt32` 返回 `false`，表示**失败啦**。

这就是最典型的「**锁已被其他线程持有**」情况。

------

2.  **大家一起冲，结果只有一个赢了**

- 如果好几个 Goroutine 同一时间段都在尝试抢这个锁。

- CPU 会给他们机会竞争，但**原子操作只有一个能成功**。

- 其他的 Goroutine 虽然一开始看到锁是空的，但来得慢了一点点～

- 等真正执行到 `CompareAndSwap` 时，锁已经被抢了。

  所以他们的修改尝试也会**失败**。

这就是所谓的「**高并发竞争条件**」。

#### 优化方案

+ **<font style="color:#DF2A3F;">设置自旋次数限制</font>**：为了避免在锁被长时间持有时浪费CPU资源，可以为自旋锁设置自旋次数的限制。一旦达到该限制，尝试获取锁的线程将放弃自旋并进入睡眠状态，等待锁被释放。
+ **使用退避策略**：在自旋期间，可以尝试使用退避策略（如指数退避），以减少CPU的占用率并提高系统的整体性能。（如：**饥饿模式**）
+ **考虑使用其他同步机制**：如果自旋锁不适用于特定场景（如锁持有时间较长、竞争激烈等），则可以考虑使用其他<font style="color:#DF2A3F;">同步机制（如互斥锁、读写锁</font>等）。

### 10.goroutine 的自旋占用资源如何解决

Goroutine 的自旋占用资源问题主要涉及到 Goroutine 在等待锁或其他资源时的一种行为模式，即自旋锁（spinlock）。<font style="color:#DF2A3F;">自旋锁是指当一个线程（在 Go 中是 Goroutine）在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待（自旋），不断判断锁是否已经被释放，而不是进入睡眠状态</font>。这种行为在某些情况下可能会导致资源的过度占用，特别是当锁持有时间较长或者自旋的 Goroutine 数量较多时。

针对 Goroutine 的自旋占用资源问题，可以从以下几个方面进行解决或优化：

1. **减少自旋锁的使用**  
   评估必要性：首先评估是否真的需要使用自旋锁。<font style="color:#DF2A3F;">在许多情况下，互斥锁（mutex）已经足够满足需求</font>，因为互斥锁在资源被占用时会让调用者进入睡眠状态，从而减少对 CPU 的占用。  
   优化锁的设计：考虑使用更高级的同步机制，<font style="color:#DF2A3F;">如读写锁（rwmutex），它允许多个读操作同时进行，而写操作则是互斥的</font>。这可以显著减少锁的竞争，从而降低自旋的需求。
2. **优化自旋锁的实现**  
   设置自旋次数限制：<font style="color:#DF2A3F;">在自旋锁的实现中加入自旋次数的限制，当自旋达到一定次数后，如果仍未获取到锁，则让 Goroutine 进入睡眠状态</font>。这样可以避免长时间的无效自旋，浪费 CPU 资源。  
   利用 Go 的调度器特性：Go 的调度器在检测到 Goroutine 长时间占用 CPU 而没有进展时，会主动进行抢占式调度，将 Goroutine 暂停并让出 CPU。这可以在一定程度上缓解自旋锁带来的资源占用问题。
3. 监控和调整系统资源  
   监控系统性能：通过工具（如 pprof、statsviz 等）监控 Go 程序的运行时性能，包括 CPU 使用率、内存占用等指标。这有助于及时发现和解决资源占用过高的问题。  
   调整 Goroutine 数量：根据系统的负载情况动态调整 Goroutine 的数量。例如，在高并发场景下适当增加 Goroutine 的数量以提高处理能力，但在负载降低时及时减少 Goroutine 的数量以避免资源浪费。
4. 利用 Go 的并发特性  
   充分利用多核 CPU：通过设置 runtime.GOMAXPROCS 来指定 Go 运行时使用的逻辑处理器数量，使其尽可能接近或等于物理 CPU 核心数，从而充分利用多核 CPU 的并行处理能力。  
   **使用 Channel 进行通信**：<font style="color:#DF2A3F;">Go 鼓励使用 Channel 进行 Goroutine 之间的通信和同步，而不是直接使用锁</font>。Channel 可以有效地避免死锁和竞态条件，并且减少了锁的使用，从而降低了资源占用的风险。  
   综上所述，解决 Goroutine 的自旋占用资源问题需要从多个方面入手，包括减少自旋锁的使用、优化自旋锁的实现、监控和调整系统资源以及充分利用 Go 的并发特性等。通过这些措施的综合应用，可以有效地降低 Goroutine 在自旋过程中对系统资源的占用。

