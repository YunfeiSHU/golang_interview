# 八股文

## GO

- `channel` ：Goroutine 之间 通信：提供了 Goroutine 之间的同步和数据传递机制；

  ​		     发送与接收、同步和阻塞--->CSP模型；无缓冲vs有缓存

- `context`：Goroutine 之间  传递信号

  ​		    用于：管理请求的生命周期、处理超时、传递元数据、协同工作和限制并发

- `golang的并发模型`： 基于CSP，通过Goroutine与channel实习，通过通信来共享内存（而不是：共享内存来通信）

  - CSP理论：并发进程通过通信实现交互，而不是共享变量。 进程：任务的实体
    - 核心原则：通过通信实现内存共享；同步机制
  - `Goroutine`：轻量级线程，内存和资源占用小，启动和创建操作开销小；并发运行，程序在goroutine调度
  - `channel`： 发送与接收----->共享内存、同步和阻塞---->同步机制
  - `select语句`：多路复用，一个Goroutine执行多个channel操作（区分switch语句）；非阻塞操作

- `GC机制`：标记-清除过程；stop the world（推扫描，回收阶段）；

  ​		写屏障（监听指针修改）----->保证gc与程序可以并行运行

### 1.make 和 new 区别

> 指针类型：T*
>
> 引用类型：在golang中，是对指针类型的封装（新的结构体），而不是T&起别名（c++），
>
> ​		    在它的内部通过指针引用底层数据结构
>
> 引用类型的初始化：make 初始化内容 与 new 区别
>
> golang 对象在堆还是栈上：自动逃逸分析（golang：临时变量是动态的）

**共同点：**给变量分配内存
**不同点：**
1）作用变量类型不同，new给string,int和数组等基本类型分配内存，make给切片，map，channel（引用类型）分配内存；
2）返回类型不一样，new返回指向变量的指针 `*T` ，make返回变量本身 `T` ；
3）new 只分配内存，不进行额外初始化，存储的是 `T` 类型的零值。make 分配内存并初始化引用类型

> 引用类型有 切片(slice)、字典(map)、接口(interface)、函数(func) 以及 通道(chan) 。
>
> 1. 引用类型不是指针，而是对指针的包装（新的结构体），在它的内部通过指针引用底层数据结构。
>
> 2. 引用类型初始化：
>
>    1. **分配内存**
>
>    2. **初始化内部指针，指向底层数据**
>
>    3. **设置相应的元数据（如 slice 的长度和容量，map 的哈希表结构，channel 的缓冲区）**

4）make 和 new 对象在推还是栈上，取决于golang 编译时的自动逃逸分析：

- **`new` 创建的对象通常分配在堆上**，因为它返回指针，而指针可能在函数返回后仍然存活，触发逃逸分析。
- **`make` 创建的对象可能分配在栈上或堆上**：
  - 如果 `make` 创建的切片或 map 在函数内使用并且不会逃逸，可能被优化为 **栈分配**。
  - 如果 `make` 创建的对象需要在函数外存活（如返回值或存储在全局变量中），则会 **逃逸到堆上**。

> 在 Go 语言中，**是否分配到堆或栈主要依赖于编译器的逃逸分析**：
>
> - 如果编译器检测到一个变量不会在函数返回后被访问，它可能会被分配在 **栈** 上（性能更优）。
>
> - 反之，如果变量会在函数返回后继续存活，它会被分配在 **堆** 上，以避免访问栈上的失效数据。
>
>   即：全局变量在堆上；临时变量默认在栈，逃逸后在堆上



### 2.IO多路复用 TODO



### 3.for a,b := range, a(b)地址不发生变化

在 for a,b := range c 遍历中， a 和 b 在内存中只会存在一份，即之后每次循环时遍历到的数据都是以值覆盖的方式赋给 a 和 b，a，b 的内存地址始终不变。由于有这个特性，for 循环里面如果开协程，不要直接把 a 或者 b 的地址传给协程。**解决办法：在每次循环时，创建一个临时变量。**

例子：

```go
s := []int{10, 20, 30}

	for _, v := range s {
		go func() {
			fmt.Println(v) // ❌ 可能全部输出 30
		}()
	}

	time.Sleep(time.Second) // 等待 Goroutine 执行
```

**goroutine 在执行时，可能 `for range` 已经结束了，`v` 变成了最后一个值**

```go
//解决方案 1
	s := []int{10, 20, 30}

	for _, v := range s {
		vCopy := v // ✅ 解决方法：创建局部变量
		go func() {
			fmt.Println(vCopy)
		}()
	}Copy

	time.Sleep(time.Second)
//解决方案 2
for _, v := range s {
	go func(val int) {
		fmt.Println(val)
	}(v) // ✅ 传递参数，避免变量覆盖
}
```



### 4.go defer ：多个defer ， defer修改函数返回值

defer的7个知识点：

defer的执行顺序：以栈的形式，指向多个defer语句；

defer 和 return 谁先谁后： 先return，后defer

函数的返回值初始化 + 有名函数返回值遇见defer情况 ： defer 修改 有名函数返回值/临时变量指针（不能是本身）

> **golang 函数返回值，都是值传递**：
>
> 返回 临时变量（数组，结构体，字符串），通过值拷贝形式，返回；
>
> 返回 临时变量指针时，**返回指针的值拷贝**
>
> 返回 引用类型时，返回**引用类型的值拷贝（拷贝了：**指向底层类型的指针**）:虽不拷贝底层类型**，但修改返回值，原变量也会修改

```go
func b() int { // ❌ i 不是有名返回值
    i := 0
    defer func() {
        i++ // ❌ 这里修改的是 `i` 的局部变量，不会影响返回值
        fmt.Println("defer2:", i)
    }()
    defer func() {
        i++
        fmt.Println("defer1:", i)
    }()
    return i // ✅ 直接返回 i 的值，defer 修改的是局部变量，返回值不受影响
}

func main() {
    fmt.Println("return:", b())
}
//return 时 i 已被拷贝，defer 修改的是局部变量
```

defer 遇见 panic ：panic 之后的defer不会执行，之前defer顺序出栈；

defer 捕获 panic ：当第一个defer捕获panic，其他defer 产生panic，则捕获按栈执行，最后产生的panic

defer下的函数参数包含子函数 ：

```go
 defer function(1, function(3, 0))
 defer function(2, function(4, 0))
//3 4 2 1
```

defer的压栈，传入：函数地址 + 形参；如果形参包含子函数，则先执行后，传入返回值。



###5. 类型溢出问题

![image-20250406110055936](./assets/image-20250406110055936.png)

```
var a uint8 =255
var b uint8 =1
a+b = 0
```



### 6. rune 类型

相当int32
golang中的字符串底层实现是通过byte数组的，中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8
byte 等同于uint8，常用来处理ascii字符
rune 等同于int32,常用来处理unicode或utf-8字符



### 7.**golang 中解析 tag 是怎么实现的？反射原理是什么？**

> tag--->reflect

1. **tag 是 Go 结构体字段中的“元信息”**，一般用于额外标注字段信息，常用于序列化（如 JSON）、数据库映射（如 GORM）等

2. 解析tag：**通过反射实现的**

3. 反射将接口变量转换成反射对象 Type 和 Value；反射可以通过反射对象 Value 还原成原先的接口变量；

```go
var x interface{} = 42

t := reflect.TypeOf(x)   // 获取类型信息
v := reflect.ValueOf(x)  // 获取值信息

fmt.Println(t.Kind())    // int
fmt.Println(v.Int())     // 42
```

​	反射可以用来修改一个变量的值，前提是这个值可以被修改；

> Go 中默认通过反射获取到的变量是不可修改的，只有获取它的**指针并调用 `Elem()`** 后，才可以修改

```go
var a int = 10
v := reflect.ValueOf(&a) // 必须传指针
v.Elem().SetInt(20)      // 修改原变量的值
fmt.Println(a)           // 输出 20
```

总结：

在 Go 语言中，结构体的字段可以通过 tag（标签）来附加额外的元信息，比如 `json:"name"`、`db:"username"` 等。这些 tag 是字符串，会在运行时通过 **反射（reflect 包）** 来解析。

Go 的反射机制可以把一个变量转为两个核心对象：

- `reflect.Type`：表示变量的类型信息（如字段名、tag、方法等）
- `reflect.Value`：表示变量的值，可以用来读写变量内容。

通过反射，我们不仅可以读取 tag，还可以在一定条件下修改变量的值。要注意，**只有值是可寻址（addressable）并且可以导出（exported）时，才允许修改**。

> 可寻址：**想要通过反射修改变量，就得传指针！**
>
> 可导出： 字段首字母要 **大写** 

所以总结来说：Go 中解析 tag 是通过反射读取结构体字段的 `Tag` 字段实现的，而反射的核心能力在于操作 `Type` 和 `Value` 来动态获取和修改信息。



### 8.golang 函数返回值 都是值传递

**golang 函数返回值，都是值传递**：

返回 临时变量（数组，结构体，字符串），通过值拷贝形式，返回；

返回 临时变量指针时，**返回指针的值拷贝**

返回 引用类型时，返回**引用类型的值拷贝（拷贝了：**指向底层类型的指针**）:虽不拷贝底层类型**，但修改返回值，原变量也会修改

> 变量区分值类型和引用类型。
>
> 所谓值类型：变量和变量的值存在同一个位置。
>
> 所谓引用类型：变量和变量的值是不同的位置，变量的值存储的是对值的引用。



### 9.goroutine什么情况下会阻塞

> GPM调度模型：
>
> ```
> G: Goroutine（协程）
> M: Machine（系统线程）
> P: Processor（调度器）
> 
>       ┌───────┐
>       │  G1   │
>       │  G2   │
>       │  G3   │      ← G 队列（本地运行队列）
>       └───────┘
>            ▲
>            │
>            ▼
> ┌───┐   ┌───────┐   ┌───┐
> │ G │ ← │   P   │ → │ M │
> └───┘   └───────┘   └───┘
>                ↑
>                │ 系统调度的线程池，M 绑定执行
>                ▼
>           操作系统调度器
> 
> ```
>
> 创建go程：`go func(){}()` 创建一个G对象，加入当前P的本地队列
>
> 执行go程：G → P → M（调度器P将G绑定到指定M来执行）
>
> ​		    P 负责从队列里取出 G；M 是真正执行代码的系统线程；G 绑定到 M，通过 P 调度执行
>
> go程阻塞：
>
> - 如果 G 阻塞了（如 I/O），M 也会停下来；
> - Runtime 会解绑 P，找一个新的 M 来继续执行；
> - 或者把 P 放回“空闲池”等待被别的 M 抢占。
>
> G 数量 > P 数量怎么办？
>
> - G 太多执行不过来怎么办？
> - 会有一个 **全局队列** GQ，未分配到 P 的 G 会放进去；
> - 各个 P 会去偷别的 P 或者全局队列的 G 来执行。
>
> **为什么默认 GOMAXPROCS 是逻辑 CPU 数？**
> 因为 P 的数量 == 可并行执行的最大 G 数量，**默认就是逻辑核心数**，这样能最大程度利用 CPU 资源。

1.  **同步原语阻塞**：互斥锁 / 原子操作 / Channel 阻塞

   - `sync.Mutex`、`sync.RWMutex` 等锁竞争；
   - Channel 的发送和接收操作（没有配对的一方就会阻塞）；
   - 使用 `sync.Cond`、`sync.WaitGroup` 等阻塞等待信号。

   表现：当前 Goroutine 无法继续执行，调度器会”挂起“它（ **让出执行权**），切换运行队列中的其他 Goroutine

2. **网络 IO 阻塞**：通过 NetPoller 机制处理

   - Go 底层通过 epoll（Linux）/ kqueue（macOS）/ IOCP（Windows）实现**非阻塞网络 IO + 多路复用**；
   - 即使你用的是阻塞的 API，如 `conn.Read()`，Go runtime 也会通过 **NetPoller** 封装成非阻塞的；
   - 所以网络阻塞并不会阻塞操作系统线程 M，而是挂起 Goroutine，等待 IO 准备好再恢复

   表现：网络请求会让 Goroutine 阻塞，但 M 不会被占住！

3. **系统调用阻塞**（如文件 I/O）

   - 和网络 I/O 不同，某些 **系统调用是阻塞的**，如文件操作（尤其是调用 C 函数时）；
   - Go 调度器一旦发现 M 被系统调用阻塞，会为其绑定的 P 创建一个新的 M，继续调度其他 G

   表现：阻塞系统调用导致 M 阻塞，P 被转移给新 M

4.  **Goroutine 主动调用 sleep / select 等等待操作**

   - 如 `time.Sleep`、`select{}`（无 case）等，会显式让当前 Goroutine 阻塞；

   表现：这时候不会占用 M 的执行时间，调度器会调度其他 G。

| 场景                     | 是否阻塞 Goroutine | 是否阻塞 M（系统线程） | 说明                   |
| ------------------------ | ------------------ | ---------------------- | ---------------------- |
| Mutex/Channel 等同步原语 | ✅ 会               | ❌ 不会                 | 调度器切 G，M 不受影响 |
| 网络 IO（socket）        | ✅ 会               | ❌ 不会                 | NetPoller 转异步 IO    |
| 系统调用（文件、C 函数） | ✅ 会               | ✅ 会                   | 调度器增加 M           |
| `time.Sleep/select{}`    | ✅ 会               | ❌ 不会                 | 自愿挂起，调度器调度   |



### 10. Go 的 select 底层数据结构和一些特性？TODO





### 11. Go 的 defer 底层数据结构和一些特性？TODO



### 12.**单引号，双引号，反引号的区别？**

**单引号**，表示byte类型或rune类型，对应 uint8和int32类型，**默认是 rune 类型**。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。
**双引号**，才是**字符串**，实际上是字符数组。可以用索引号访问某字节，也可以用len()函数来获取字符串所占的字节长度。
**反引号**，表示**字符串字面量**，但不支持任何转义序列：定义时写的啥样，它就啥样，你有换行，它就换行。你写转义字符，它也就展示转义字符。



### 13.出现panic场景：

✅ 一、运行时错误（runtime error）

1. **数组 / 切片越界访问**

   ```
   a := []int{1, 2}
   fmt.Println(a[3]) // panic: index out of range
   ```

2. **除以 0**

   ```
   x := 1
   y := 0
   fmt.Println(x / y) // panic: integer divide by zero
   ```

3. **空指针调用（nil 指针解引用）**

   ```
   var p *Person
   fmt.Println(p.Name) // panic: nil pointer dereference
   ```

4. **sync.WaitGroup 计数为负**

   ```
   var wg sync.WaitGroup
   wg.Add(-1) // panic: sync: negative WaitGroup counter
   ```

------

✅ 二、channel 操作异常

1. **向已关闭的 channel 发送数据**

   ```
   ch := make(chan int)
   close(ch)
   ch <- 1 // panic: send on closed channel
   ```

2. **关闭已经关闭的 channel**

   ```
   ch := make(chan int)
   close(ch)
   close(ch) // panic: close of closed channel
   ```

3. **关闭未初始化的 channel**

   ```
   go复制编辑var ch chan int
   close(ch) // panic: close of nil channel
   ```

------

✅ 三、map 操作异常

1. **写入未初始化的 map**

   ```
   var m map[string]int
   m["x"] = 1 // panic: assignment to entry in nil map
   ```

> 🔸**注意**：访问未存在的 key 不会 panic，但**不能直接赋值到 nil map**。

------

✅ 四、类型断言失败

1. **不带判断的类型断言失败**

   ```
   var x interface{} = 100
   s := x.(string) // panic: interface conversion: int is not string
   ```

> ✅ 建议用：
> `s, ok := x.(string)` 来避免 panic。

------

✅ 五、其他特殊情况

1. **HTTP 响应体未正确关闭**

```
// resp.Body.Close() 写在 defer 前已经 return，就不会执行到
// 或者多次 close 也可能引发问题（依赖具体实现）
```

2. **跨协程 panic 未被 recover 捕获**
   `recover()` 只能捕获当前 goroutine 内的 panic。



### 14.Go中有无while，如何实现？

| 功能          | Go 语法                     | 等价 C/Java   |
| ------------- | --------------------------- | ------------- |
| while 循环    | `for 条件 {}`               | `while`       |
| 无限循环      | `for {}`                    | `while(true)` |
| for 条件+步进 | `for i := 0; i < n; i++ {}` | `for`         |



### 15.Go模拟Set

Go 语言中确实**没有内置的 Set 类型**，但可以使用 `map[T]struct{}` 来优雅地模拟一个 Set 

为什么用 `map[T]struct{}` 来实现 Set？

- `map` 的 key 具有 **唯一性**，可以天然去重 ✅
- `struct{}` 是 **空结构体**，占用 0 字节，节省内存 ✅
- 操作效率高，查找、添加、删除都是常数时间 O(1)

```go
  // 创建一个字符串集合
    set := make(map[string]struct{})

    // 添加元素
    set["apple"] = struct{}{}
    set["banana"] = struct{}{}
    set["cherry"] = struct{}{}

    // 判断是否存在
    if _, exists := set["banana"]; exists {
        fmt.Println("banana 在集合中")
    }

    // 删除元素
    delete(set, "banana")

    // 遍历集合
    for key := range set {
        fmt.Println(key)
    }
```



### 16.Go通过组合实现继承

```go
// 父类结构
type Animal struct {
    Name string
}

func (a Animal) Speak() {
    fmt.Println(a.Name + " 发出声音")
}

// 子类结构，嵌套 Animal，相当于“继承”
type Dog struct {
    Animal // 匿名字段，实现组合
    Breed  string
}
```

- 如果一个 struct 嵌套了另一个匿名结构体，那么这个结构可以直接访问匿名结构体的属性和方法，从而实现继承。
- 如果一个 struct 嵌套了另一个有名的结构体，那么这个模式叫做组合。
- 如果一个 struct 嵌套了多个匿名结构体，那么这个结构可以直接访问多个匿名结构体的属性和方法，从而实现多重继承。



### 17.如何复用接口的方法？

```
package main

import "fmt"

// 定义一个接口，包含基本方法
type Speaker interface {
    Speak() string
}

// 定义一个接口，组合了 Speaker 接口
type Greeter interface {
    Speaker
    Greet() string
}

// 实现 Speaker 接口
type Person struct {
    Name string
}

func (p Person) Speak() string {
    return "Hello, my name is " + p.Name
}

// 实现 Greeter 接口
func (p Person) Greet() string {
    return "Good morning!"
}

func main() {
    p := Person{Name: "Alice"}

    // 使用 Greeter 接口
    var g Greeter = p
    fmt.Println(g.Speak()) // 调用 Speaker 接口的方法
    fmt.Println(g.Greet()) // 调用 Greeter 接口的方法
}
```



### 18.Go中_的使用

1. **创建临时变量：**

####  **检查接口是否被指定结构体实现？**

```go
type T struct{}    // 定义一个类型 T
var _ X = T{}     // 通过类型断言判断 T 是否实现了接口 X


package main

import "fmt"

// 定义接口 X
type X interface {
    Speak() string
}

// 定义类型 T
type T struct{}

// T 没有实现接口 X 中的 Speak 方法

func main() {
    // 编译错误：cannot use T{} (type T) as type X in assignment: T does not implement X (missing Speak method)
    var _ X = T{}
}
```

#### **忽略参数**

```
v1, v2, _ := function(...)
v1, _, _ := function(...)
```

2. **只使用这个包的init方法**

```go
import _ "test/food"
```



### 19.for loop 中给go程传递参数

**goroutine 在执行时，可能 `for range` 已经结束了，`v` 变成了最后一个值**

```go
//解决方案 1
	s := []int{10, 20, 30}

	for _, v := range s {
		vCopy := v // ✅ 解决方法：创建局部变量
		go func() {
			fmt.Println(vCopy)
		}()
	}

	time.Sleep(time.Second)
//解决方案 2
for _, v := range s {
	go func(val int) {
		fmt.Println(val)
	}(v) // ✅ 传递参数，避免变量覆盖
}

```



### 20.单元测试文件命名规范 TODO



### 21.导入一个项目，有些依赖找不到，该怎么办

```powershell
#检查是否有go.mod文件，没有则：
go mod init <module-name>
#有go.mod，自动修复依赖问题
go mod tidy 
#依赖版本问题：
go get -u #将所有依赖升级为最新版本
go get -u <package-path>

```



### 
