# 八股文-7

## 并发相关

### 1.Go 中主协程如何等待其余协程退出?

（1）**最主流、最正确的办法就是用 `sync.WaitGroup`！**

1. 主协程调用 `wg.Add(n)` —— **告诉WaitGroup：我要开n个协程！**
2. 每个子协程做完后，调用 `wg.Done()` —— **告诉WaitGroup：我这个协程做完啦！**
3. 主协程调用 `wg.Wait()` —— **乖乖等着，直到所有的子协程都Done**

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var wg sync.WaitGroup

    wg.Add(3) // 开启3个协程，要Add(3)

    go func() {
        fmt.Println("Goroutine 1 done")
        wg.Done()
    }()

    go func() {
        fmt.Println("Goroutine 2 done")
        wg.Done()
    }()

    go func() {
        fmt.Println("Goroutine 3 done")
        wg.Done()
    }()

    wg.Wait() // 等待所有子协程完成
    fmt.Println("All goroutines finished!")
}

```

（2）**用channel也能实现等待**

**有缓冲的channel** 等待一组goroutine完成**（并发执行）**

- 每个子协程完成后，往 channel 里写一个值。
- 主协程在外面读 n 次，读完说明所有子协程完成。

```go
package main

import (
    "fmt"
)

func main() {
    ch := make(chan struct{}, 3) // 有缓冲，容量为3

    for i := 1; i <= 3; i++ {
        go func(id int) {
            fmt.Printf("Goroutine %d done\n", id)
            ch <- struct{}{}
        }(i)
    }

    // 读取3次，等所有协程完成
    for i := 0; i < 3; i++ {
        <-ch
    }

    fmt.Println("All goroutines finished!")
}

```

**无缓冲 channel** 读写要一一配对，所以适合那种**控制顺序执行**的场景，不适合真正的并发等待一组完成。

#### （无缓冲channel）3个协程交替顺序打印数字

> 有缓存管道实现的话，参考2.（1）；虽然一直也是三个go程，但不断会有新go程产生，老go程被回收

```go
package main

import (
    "fmt"
)

func main() {
    // 准备三个无缓冲的channel，用来做接力棒
    chA := make(chan int)
    chB := make(chan int)
    chC := make(chan int)

    // 启动三个协程
    go printNum("A", chA, chB)
    go printNum("B", chB, chC)
    go printNum("C", chC, chA)

    // 开始游戏！初始给A一个数1
    chA <- 1

    // 让主协程不退出
    select {}
}

// 打印数字并把数字+1传给下一个协程
func printNum(name string, thisChan, nextChan chan int) {
    for {
        num := <-thisChan // 等待接力棒（阻塞）
        fmt.Printf("%s 打印 %d\n", name, num)

        if num >= 30 { // 打印到30就结束（可以自由调整）
            close(nextChan) // 通知大家结束
            return
        }

        nextChan <- num + 1 // 把接力棒交给下一个
    }
}
```



### 2.怎么控制并发数？

#### （1）WaitGroup + 有缓冲channel

- 有缓冲的 Channel，容量是固定的，比如 `chan struct{} {容量10}`。
- 每个协程要启动前，必须先向 Channel 里塞一个元素。
- 当 Channel 满了（已经有 10 个元素了），**写入会阻塞**，
  也就是说：**最多只能有10个协程在活跃执行**！
- 执行完以后从 Channel 里拿出（读出）一个元素，释放一个名额。

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    count := 10                 // 最大并发数
    sum := 100                  // 任务总数
    wg := sync.WaitGroup{}       // 用来等待所有子协程完成
    c := make(chan struct{}, count) // 控制并发数量的channel

    defer close(c)

    for i := 0; i < sum; i++ {
        wg.Add(1)
        c <- struct{}{} // 占一个位置，如果满了就阻塞
        go func(j int) {
            defer wg.Done()
            fmt.Println(j)
            <-c // 释放一个位置
        }(i)
    }

    wg.Wait() // 等待所有任务完成
}
```

#### (2)使用**三方库**实现**协程池**

> 协程池是什么？
>
> - **本质：** 是一个**任务调度器 + 协程复用器**。
> - **作用：** 限制**同时运行的协程数量**，防止开太多协程把内存打爆，还能**复用已有协程**，提高效率！
> - **特点：** 控制并发量，复用资源，适合**成千上万任务并发的场景**。

- `tunny` 是一个超轻量的 Goroutine 池库。
- 它把“启动协程、并发控制、资源复用”等繁琐细节都帮你封装好了。
- 只需要创建一个池子，比如 10 个工人，然后不停往池子里丢任务，它自己帮你调度，**最多只有10个任务同时执行**。

```go
package main

import (
    "github.com/Jeffail/tunny"
    "log"
    "time"
)

func main() {
    // 创建一个有10个工人的协程池
    pool := tunny.NewFunc(10, func(i interface{}) interface{} {
        log.Println(i)
        time.Sleep(time.Second) // 模拟处理任务耗时
        return nil
    })
    defer pool.Close()

    for i := 0; i < 500; i++ {
        go pool.Process(i) // 投递任务
    }

    time.Sleep(time.Second * 4) // 简单粗暴地等待一段时间
}
```

#### 等待池和协程池区别

| 名字                           | 主要功能                   | 控制并发数量 | 复用协程 | 适合场景               |
| :----------------------------- | :------------------------- | :----------- | :------- | :--------------------- |
| `sync.WaitGroup`+有缓冲channel | 等待一组任务做完           | ❌            | ❌        | 少量任务，控制执行顺序 |
| 协程（go程）池（如 tunny）     | 控制最大并发数，并复用协程 | ✅            | ✅        | 超大量任务，省资源     |



### 3.多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？

**可以捕获异常，但是只能捕获一次，Go语言，可以使用多值返回来返回错误。**不要用异常代替错误，更不要用来控制流程。在极个别的情况下，才使用Go中引入的Exception处理：defer, panic, recover Go中，对异常处理的原则是：多用error包，少用panic

```go
defer func() {
    if err := recover(); err != nil {
        // 打印异常，关闭资源，退出此函数
        fmt.Println(err)
    }
}()
```



### 4.如何优雅的实现一个 goroutine 池

- **任务 channel（任务队列）**：等着执行的任务
- **worker（工人）**：真正跑任务的 goroutine
- **worker pool（工人池）**：固定数量的活跃 worker
- **控制最大数量**：防止goroutine数量无限增长

```go
package main

import (
	"fmt"
	"time"
)

type Task func()

type Pool struct {
	taskChan chan Task
}

func NewPool(workerNum int) *Pool {
	pool := &Pool{
		taskChan: make(chan Task),
	}
	// 启动固定数量的worker
	for i := 0; i < workerNum; i++ {
		go pool.worker(i)
	}
	return pool
}

func (p *Pool) worker(id int) {
	for task := range p.taskChan {
		fmt.Printf("Worker %d 开始执行任务\n", id)
		task()
	}
}

func (p *Pool) Submit(task Task) {
	p.taskChan <- task
}

func (p *Pool) Close() {
	close(p.taskChan)
}

func main() {
	pool := NewPool(3) // 固定3个worker

	for i := 0; i < 10; i++ {
		i := i
		pool.Submit(func() {
			fmt.Printf("处理任务 %d\n", i)
			time.Sleep(time.Second)
		})
	}

	pool.Close()

	// 小提示：主程序需要等待子任务完成，不然可能提早退出
	time.Sleep(5 * time.Second)
}

```

> **面试官一般会顺着追问的问题！**
>
> - goroutine池和协程调度器（GMP模型）关系？
> - 高峰流量怎么办？（限流、降级）
> - 消费不过来的任务怎么设计？（比如等待排队/抛弃/优雅超时）
> - 如何优雅退出池？（比如停接新任务，让老任务做完）
> - ants底层怎么做的？（复用worker goroutine，不每次新建）
> - 超大规模场景，比如百万并发池怎么优化？



### 5.golang实现多并发请求（发送多个get请求）

在[go语言](https://so.csdn.net/so/search?q=go%E8%AF%AD%E8%A8%80&spm=1001.2101.3001.7020)中其实有两种方法进行协程之间的通信。**一个是共享内存、一个是消息传递**  

#### [**共享内存（互斥锁）**](https://blog.csdn.net/m0_43432638/article/details/108359182)

- 定义一个 **全局计数器 counter**。
- 每个 `httpget` 函数里：
  - `lock.Lock()` 加锁
  - counter++
  - 发 GET 请求，处理响应
  - `lock.Unlock()` 解锁
- 主线程 while 循环不断检测 counter 达到目标值。

```go
//基本的GET请求
package main
 
import (
    "fmt"
    "io/ioutil"
    "net/http"
    "time"
    "sync"
    "runtime"
)
 
// 计数器
var counter int = 0
 
func httpget(lock *sync.Mutex){
    lock.Lock()
    counter++
    resp, err := http.Get("http://localhost:8000/rest/api/user")
    if err != nil {
        fmt.Println(err)
        return
    }
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    fmt.Println(string(body))
    fmt.Println(resp.StatusCode)
    if resp.StatusCode == 200 {
        fmt.Println("ok")
    }
    lock.Unlock()
}
 
func main() {
    start := time.Now()
    lock := &sync.Mutex{}
    for i := 0; i < 800; i++ {
        go httpget(lock)
    }
    for  {
        lock.Lock()
        c := counter
        lock.Unlock()
        runtime.Gosched()
        if c >= 800 {
            break
        }
    }
    end := time.Now()
    consume := end.Sub(start).Seconds()
    fmt.Println("程序执行耗时(s)：", consume)
}
```

| 优点                     | 缺点                               |
| :----------------------- | :--------------------------------- |
| 能控制同步，适合小型并发 | 锁很多，容易死锁，代码臃肿，不优雅 |
| 直接                     | 增加维护难度，不适合高并发         |

#### [**消息传递（管道）**](https://blog.csdn.net/m0_43432638/article/details/108349384)

- 创建一个**chan数组**，每个协程自己有一个chan。
- 每发起一个GET请求，就启动一个协程，同时把自己的chan丢进去。
- 协程请求完毕 `ch <- 1`，主协程依次 `<-ch` 收消息确认完成。

```go
//基本的GET请求
package main
 
import (
    "fmt"
    "io/ioutil"
    "net/http"
    "time"
)
// HTTP get请求
func httpget(ch chan int){
    resp, err := http.Get("http://localhost:8000/rest/api/user")
    if err != nil {
        fmt.Println(err)
        return
    }
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    fmt.Println(string(body))
    fmt.Println(resp.StatusCode)
    if resp.StatusCode == 200 {
        fmt.Println("ok")
    }
    ch <- 1
}
// 主方法
func main() {
    start := time.Now()
    // 注意设置缓冲区大小要和开启协程的个人相等
    chs := make([]chan int, 2000)
    for i := 0; i < 2000; i++ {
        chs[i] = make(chan int)
        go httpget(chs[i])
    }
    for _, ch := range chs {
        <- ch
    }
    end := time.Now()
    consume := end.Sub(start).Seconds()
    fmt.Println("程序执行耗时(s)：", consume)
}
```

| 优点                 | 缺点                                           |
| :------------------- | :--------------------------------------------- |
| 不需要加锁，自然同步 | 需要管理好多chan，数量大时开销大               |
| 简单易懂，逻辑清晰   | 如果量非常大，可以考虑更优结构，比如公共大通道 |



### 6.sync.Pool

**什么是 `sync.Pool`？**

`sync.Pool` 是 Go 标准库 `sync` 包里的一个**对象缓存池**。
它的主要作用是 —— **临时存放对象，复用对象，减少频繁的内存分配与垃圾回收（GC）开销**。

------

**`sync.Pool` 的主要特点**

| 特性             | 解释                                           |
| :--------------- | :--------------------------------------------- |
| ✅ 减少 GC 压力   | 对象复用，减少了频繁的 `new` 和垃圾回收        |
| ✅ 并发安全       | 多个 Goroutine 可以**同时**取/放对象           |
| ⚡ 自动清空       | 每次 GC 发生时，`sync.Pool` 里的对象可能被清空 |
| ❗ 对象状态不确定 | 取出的对象可能不是「干净」的，需要自己重置     |

------

**什么时候适合用 `sync.Pool` 呢？**

适合这种场景：

- **对象创建很贵**（比如一个复杂的结构体初始化很麻烦）
- **对象生命周期短**（比如一个请求处理完就不用了）
- **并发很高**（大家都在抢着用对象）

例如：

- HTTP服务器里处理请求的临时 buffer
- JSON解析用的小结构体
- 网络连接池的一部分资源管理（但⚡ 注意，真正需要精细控制生命周期的连接池，还是要自己管理，不适合只用 `sync.Pool`）

------

**如何使用 `sync.Pool`**

1. **创建 Pool：`&sync.Pool{New: func() interface{} { return new (*Type)}}`**

```go
var pool = &sync.Pool{
    New: func() interface{} {
        return new(YourType) // 这里写需要复用的类型
    },
}
```

2. **取对象：`pool.Get().(*Type)`**

```go
obj := pool.Get().(*YourType) // 记得类型断言哦！
```

3. **用完放回去:  `pool.Put(obj)`**

```go
pool.Put(obj)
```

------

**完整的小示例**

比如我们要频繁使用一个 `[]byte` 缓冲区：

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var bytePool = &sync.Pool{
        New: func() interface{} {
            return make([]byte, 1024) // 预先分配好大小
        },
    }

    // 模拟多个 goroutine 并发使用
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            buf := bytePool.Get().([]byte)
            fmt.Printf("Goroutine %d got buffer of size: %d\n", id, len(buf))
            
            // 假装做了点什么...
            
            // 放回池子
            bytePool.Put(buf)
        }(i)
    }

    wg.Wait()
}
```

------

注意事项总结：

​	**sync.Pool 是临时缓存**，**不是持久保存**，GC可能随时清空它！

​	**取出来的对象一定要初始化**，不能假设是新的哦

​	**不适合控制精细生命周期**，比如连接池、重要资源管理不要只靠 `sync.Pool` 



## 垃圾回收

> Go GC 采用三色标记算法配合混合写屏障机制，在保证准确回收的同时大大减少 STW 时间，实现了高效的并发垃圾回收。

+ **<font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">算法</font>**<font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">：Golang采用</font><font style="color:#DF2A3F;background-color:rgb(253, 253, 254);">三色标记清扫法进行垃圾回收，</font><font style="background-color:rgb(253, 253, 254);">以减少STW（Stop The World）的时间</font><font style="color:#DF2A3F;background-color:rgb(253, 253, 254);">。</font>**<font style="color:#DF2A3F;background-color:rgb(253, 253, 254);">写屏障技术</font>**<font style="background-color:rgb(253, 253, 254);">被用来避免在并发标记过程中产生的误清扫问题。</font>
+ **<font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">触发条件</font>**<font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">：垃圾回收的触发条件包括内存分配达到一定比例、长时间未触发GC、手动调用runtime.GC()等。</font>

### 1.三色标记清扫法的流程

<font style="color:rgb(31, 35, 40);">为什么需要三色标记？</font>

**<font style="color:rgb(31, 35, 40);">三色标记的目的</font>**<font style="color:rgb(31, 35, 40);">：</font>

1. <font style="color:rgb(31, 35, 40);">主要是利用Tracing GC(Tracing GC 是垃圾回收的一个大类，另外一个大类是引用计数) </font><font style="color:#DF2A3F;">做增量式垃圾回收，降低最大暂停时间</font><font style="color:rgb(31, 35, 40);">。</font>
2. <font style="color:#DF2A3F;">原生Tracing GC只有黑色和白色，没有中间的状态，这就要求GC扫描过程必须一次性完成，得到最后的黑色和白色对象</font><font style="color:rgb(31, 35, 40);">。在前面增量式GC中介绍到了，</font><font style="color:#DF2A3F;">这种方式会存在较大的暂停时间</font><font style="color:rgb(31, 35, 40);">。</font>
3. <font style="color:#DF2A3F;">三色标记增加了中间状态灰色</font><font style="color:rgb(31, 35, 40);">，增量式GC运行过程中，</font><font style="color:#DF2A3F;">应用线程的运行可能改变了对象引用树，只要让黑色对象直接引用白色对象，GC就可以增量式的运行，减少停顿时间</font><font style="color:rgb(31, 35, 40);">。</font>

什么是三色标记？

1. **<font style="color:rgb(31, 35, 40);">黑色 </font>**<font style="color:rgb(31, 35, 40);">Black：表示对象是可达的，即</font>使用中的对象，黑色是已经被扫描的对象<font style="color:rgb(31, 35, 40);">。</font>
2. **<font style="color:rgb(31, 35, 40);">灰色</font>**<font style="color:rgb(31, 35, 40);"> Gary：表示</font>被黑色对象直接引用的对象，但还没对它进行扫描<font style="color:rgb(31, 35, 40);">。</font>
3. **<font style="color:rgb(31, 35, 40);">白色</font>**<font style="color:rgb(31, 35, 40);"> White：</font>白色是对象的初始颜色，如果扫描完成后，对象依然还是白色的，说明此对象是垃圾对<font style="color:rgb(31, 35, 40);">。</font>

------

三色标记的规则

- **黑色对象不能直接引用白色对象** ❌
- 黑色对象可以引用灰色对象 ✅
- 灰色对象可以引用白色对象 ✅

#### 三色标记的详细流程

> **<font style="color:rgb(31, 35, 40);">三色标记算法是对标记阶段的改进，原理如下：</font>**
>
> + **<font style="color:#DF2A3F;">起初所有对象都是白色</font>**<font style="color:rgb(31, 35, 40);">。</font>
> + <font style="color:#DF2A3F;">根出发扫描所有可达对象，标记为灰色</font><font style="color:rgb(31, 35, 40);">，放入待处理队列。</font>
> + **<font style="color:rgb(31, 35, 40);">从队列</font>**<font style="color:#DF2A3F;">取出灰色对象，将其引用对象标记为灰色</font><font style="color:rgb(31, 35, 40);">放入队列，</font><font style="color:#DF2A3F;">自身标记为黑色</font>
> + <font style="color:#DF2A3F;">此时白色对象即为垃圾，进行回收</font><font style="color:rgb(31, 35, 40);">。</font>

阶段一：准备阶段 （STW，写屏障） +  栈扫描

- **STW（Stop-The-World）**：暂停所有 goroutine，准备 GC。

- **开启写屏障（Write Barrier）**：

  - Go 1.7：Dijkstra 写屏障，需重新扫描栈。
  - Go 1.8+：**混合写屏障（Hybrid Write Barrier）**，结合插入 + 删除屏障，无需完整重扫，极大缩短 STW 时间。

- **栈扫描：**

  - **定位 Root 对象**：标记全局变量、栈、寄存器中的对象为 Root。
  - **标记 Root 为黑色**，其引用对象标为灰色并加入 `gcWork` 队列。
  - **Tiny对象优化**：无需追踪的小对象直接标记为黑色。

- 栈扫描结束后，解除STW

  ****

阶段二：并发标记（Concurrent Marking）

- **应用与 GC 并发执行**。

- **GC Goroutine** 从 `gcWork` 队列取出灰色对象：

  - 扫描其引用的白色对象，标记为灰色并加入队列。
  - 自身变为黑色。

- **写屏障生效**：在程序运行期间，对引用变动的对象自动处理：

  > 混合写屏障：（具体规则见2.）
  >
  > 在**并发标记阶段**，保证**程序运行时**新建立或删除的对象引用关系不会被垃圾回收器漏标或者误回收，
  >
  > 从而确保 GC 始终维护**正确的对象可达性关系**，避免存活对象被错误回收。

  ****

阶段三：重新标记（Re-mark，STW）

- **再次短暂停顿 STW，处理并发期间最后的指针变更。**

- 此阶段保证所有“灰色漏标对象”在最终标记前处理完毕

- **关闭写屏障**；

  ****

阶段四：清扫（Sweep）

- **并发清扫(有清扫goroutine)**：后台清扫线程开始释放未标记的白色对象内存。
- **与应用并发**，不会阻塞主线程，提升吞吐量。



### 2.混合写屏障规则是

混合写屏障（Hybrid Write Barrier）是Go1.8及以后版本引入的一种优化机制，用于优化垃圾回收（GC）过程中的内存管理，特别是为了减少STW（Stop The World）停顿时间，提高程序的响应速度。

**混合写屏障**的作用：

> 在**并发标记阶段**，保证**程序运行时**新建立或删除的对象引用关系不会被垃圾回收器漏标或者误回收，从而确保 GC 始终维护**正确的对象可达性关系**，避免存活对象被错误回收。

#### **工作原理：**

1. 插入写屏障（Insert Write Barrier）：

   - 当对象A新增指向对象B的指针时，如果B是**白色**（未标记为可达），那么**立刻标记B为灰色**，确保它不会在GC过程中被误回收。

2. 删除写屏障（Delete Write Barrier）：

   - 当对象A删除指向对象B的指针时，如果B是**灰色或白色**，则将B重新标记为**灰色**。（<font style="color:#DF2A3F;">如果是白色，则直接标记为灰色；如果是灰色，则保持灰色状态</font>）

     这样保证即使对象A删除了指向B的引用，B仍然不会被错误回收，保证在接下来的GC中能继续被扫描。



### 3.GC 的触发时机？

> “Go 的 GC 触发分为系统触发和手动触发。系统触发主要包括：堆使用量超过阈值、间隔超过默认周期（2分钟）以及首次周期触发；而手动触发则是通过调用 `runtime.GC()` 实现的。”

GC 的触发可以分为两类：**系统自动触发** 和 **手动主动触发**。

1. 系统自动触发（基于 runtime 的内部策略）：

- **gcTriggerHeap**：当当前分配的堆大小达到由 GC 控制器计算出的阈值时触发。
- **gcTriggerTime**：如果距离上一次 GC 的时间超过了 `runtime.forcegcperiod`（默认是 2 分钟），则触发。
- **gcTriggerCycle**：当程序运行时还未开启过 GC，会自动触发一次（通常在启动早期阶段）。

2. 手动触发：

- **调用 `runtime.GC()`**：用户可以显式调用 `runtime.GC()` 触发一次完整的垃圾回收周期（包括标记和清理）。

