# 八股文-2

### 22. 值拷贝vs引用拷贝---浅拷贝vs深拷贝

值拷贝 vs 引用拷贝（本质：对象是值类型还是引用类型）

| 拷贝方式 | 描述                                      | 特点                        | 例子                                                      |
| -------- | ----------------------------------------- | --------------------------- | --------------------------------------------------------- |
| 值拷贝   | 拷贝的是对象本身的数据                    | 新对象和原对象 **互不影响** | 数组 、结构体、指针等**值类型**                           |
| 引用拷贝 | 拷贝的是地址，多个变量指向 **同一块内存** | 修改一个会影响另一个        | `slice`、`map`、`chan`、`interface{}`、函数等**引用类型** |

**深拷贝 vs 浅拷贝（本质区别：是否共享底层数据）**

| 类型   | 描述                               | 示例                                                     |
| ------ | ---------------------------------- | -------------------------------------------------------- |
| 浅拷贝 | **拷贝的是“引用/地址**”            | 切片、map、channel 默认行为，**指针的值拷贝**            |
| 深拷贝 | **拷贝的是“真实数据”**，并新开空间 | 数组、结构体默认就是深拷贝，但注意也可以“手动实现”深拷贝 |

**一般的：引用拷贝 为 浅拷贝，值拷贝 为 深拷贝（有特殊情况）** 特殊点：**指针：值拷贝但属于浅拷贝**

总结：

- 引用类型拷贝，指针的值拷贝 -----> 浅拷贝
- 非指针类型的值拷贝------>深拷贝

> 结构体字段是引用类型的拷贝 ：  值拷贝  浅拷贝（同上）



### 23.精通Go项目依赖Go Modules

#### GOPATH模式

> 一开始配置的GOPATH 环境变量

![image-20250408105638572](C:\Users\79042\AppData\Roaming\Typora\typora-user-images\image-20250408105638572.png)

弊端：一句话总结：没法进行版本号控制

- **A. 无版本控制概念.** 在执行`go get`的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。

- **B.无法同步一致第三方版本号.** 在运行 Go 应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。
- **C.无法指定当前项目引用的第三方版本号. ** 你没办法处理 v1、v2、v3 等等不同版本的引用问题，因为 GOPATH 模式下的导入路径都是一样的，都是`github.com/foo/bar`。

#### Go Modules

![image-20250408110008204](C:\Users\79042\AppData\Roaming\Typora\typora-user-images\image-20250408110008204.png)

- `GO111MODULE` ：作为 Go modules 的开关
- `GOPROXY`：设置 Go 模块代理

![image-20250408110314674](C:\Users\79042\AppData\Roaming\Typora\typora-user-images\image-20250408110314674.png)



### 24.Go的多返回值如何实现的？

Go 底层是通过 **栈帧（stack frame） + offset 偏移量** 来实现的，函数调用的每个返回值都会在当前函数调用者的栈帧上 **预留一块空间**

 **内部机制依赖于下面这几个寄存器：**

| 寄存器                 | 作用                                         |
| ---------------------- | -------------------------------------------- |
| `FP` (Frame Pointer)   | 指向当前函数栈帧的起始地址（栈底）           |
| `SP` (Stack Pointer)   | 指向当前栈顶，即当前函数局部变量等数据的顶部 |
| `PC` (Program Counter) | 当前执行的下一条指令                         |
| `SB` (Static Base)     | 静态全局变量区的基地址（符号表），编译期确定 |

**举个例子：**

假设你写了这个函数：

```go
func Foo(x int) (int, string)
```

那么编译器就会生成调用协议如下（伪汇编）：

```diff
Caller:
+----------------------------+
| 参数 x        (8 bytes)    | <-- SP
| 返回值 int     (8 bytes)    |
| 返回值 string  (16 bytes)   |
+----------------------------+

调用 Foo：

- 把 x 写入偏移地址 [FP+0]
- Foo 执行后，把返回值写入偏移地址 [FP+8], [FP+16]
```

> 所以可以说： ✅ **Go 的多返回值是编译器帮你在栈帧里安排好一整块区域，按照 offset 依次填充返回值实现的。**



### 25.Go 语言中不同的类型如何比较是否相等？

| 类型             | `==`                | `reflect.DeepEqual` | 注意点             |
| ---------------- | ------------------- | ------------------- | ------------------ |
| int/float/string | ✅                   | ✅                   | `==` 性能更高      |
| array            | ✅（元素可比较）     | ✅                   |                    |
| struct           | ✅（字段都可比较）   | ✅                   |                    |
| slice            | ❌                   | ✅                   | `nil != []int{}`   |
| map              | ❌                   | ✅                   | key-value 逐个比较 |
| channel          | ✅                   | ✅                   | 只是比较地址       |
| interface        | ✅（值的类型可比较） | ✅                   | 否则 panic         |
| func             | ❌（仅能 `== nil`）  | ✅                   |                    |

**slice，map，func 不能用 `==` 比较**

易错：

```go
var a interface{} = []int{1, 2, 3}
var b interface{} = []int{1, 2, 3}
fmt.Println(a == b) // ❌ panic：invalid operation
fmt.Println(reflect.DeepEqual(a, b)) // ✅ true
```

> interface 比较前，**会先看底层类型是否可比较**，如果是 slice，就 panic。
>
> 💡 注意：interface 的底层比较，其实是比较其 “动态类型” 和 “动态值” 是否相等



### 26.Go中init 函数的特征?

1️⃣ **每个 Go 源文件 可以包含多个 `init()` 函数 **

```go
// a.go
func init() { fmt.Println("init 1") }
func init() { fmt.Println("init 2") }
```

多个 `init()` 函数在同一个文件中按代码出现的顺序执行。

------

2️⃣ **一个包中可以包含多个 `init()` 函数（在不同文件）**

比如你在一个包中有两个文件，每个都有 `init()`，它们都会被执行。

**执行顺序**：
Go 会按 **文件编译顺序（通常是文件名字母顺序）** 执行这些 init 函数。

------

3️⃣ **`init()` 函数 自动执行，不能被调用也不能传参**

```go
func init() {
    fmt.Println("初始化~")
}
```

- 不允许手动调用 `init()`
- 不能带参数，也不能有返回值
- 被设计用于“**自动初始化**”，比如设置默认值、加载配置文件等。

------

4️⃣ **包的初始化顺序是“自底向上”，且执行一次**

依赖顺序：从最深层的依赖包开始执行 `init()`，逐层往上直到 `main` 包。

比如：

```bash
main → pkgA → pkgB → pkgC
```

执行顺序是：

```scss
init(pkgC) → init(pkgB) → init(pkgA) → init(main)
```

> ✅ 注意：**无论被导入多少次，`init()` 只会执行一次**！

------

5️⃣ **变量初始化 优先于 `init()` 执行 **

```go
var config = loadConfig() // 会优先执行

func init() {
    fmt.Println("init 执行")
}
```

> 所以如果你有一些依赖顺序的初始化逻辑，要注意变量初始化的时机哦～

------

6️⃣ **`main()` 函数永远是程序执行的入口，但 `init()` 先执行 **

```go
func main() {
    fmt.Println("main 执行")
}
```

执行顺序是：

```scss
1. 全局变量初始化
2. 所有依赖包的 init()
3. 当前包的 init()
4. main()
```

**一句话总结：**

Go 的 `init()` 函数自动执行，不能调用，每个包的多个 `init()` 函数按文件顺序执行，执行顺序从最底层依赖包开始，并且只执行一次。全局变量的初始化总在 `init()` 之前。



### 27.Go中 uintptr和 unsafe.Pointer 的区别？

> 面试中关于 Go 底层内存操作的重点之一

```
  +-------------------------+     类型转换       +------------------+
  | *T (任意类型指针)       | <---------------> | unsafe.Pointer   |
  +-------------------------+                   +------------------+
                 |                                        |
                 |                                        |
                 | unsafe.Pointer → uintptr（用于运算）   |
                 ↓                                        ↓
          +--------------+                    +------------------+
          |   uintptr     | <----------------- | 指针整数（地址）  |
          +--------------+                    +------------------+

```

**概念：**

`unsafe.Pointer`：是一个 **通用指针类型**；**不能进行指针运算**；可以转换为任意 `*T` 类型（也可以从任意 `*T` 转过来）

`uintptr`：是一种整数类型（本质是 uint 类型），**可以参与运算**；表示指针的地址值（memory address）

| 属性             | `unsafe.Pointer`                   | `uintptr`                        |
| ---------------- | ---------------------------------- | -------------------------------- |
| 类型             | 指针                               | 整数（地址）                     |
| 能否指针运算     | ❌ 不可以                           | ✅ 可以                           |
| 能否保持对象引用 | ✅ 可以（参与 GC）                  | ❌ 不可以（不能保证 GC 正常工作） |
| 转换作用         | 各类型指针之间桥梁                 | 用于做偏移、算地址               |
| 适合用在哪       | 类型转换（如 `*int` → `*float64`） | 偏移地址、系统底层操作、与 C 交  |

因为 **Go 不允许你直接对 `*T` 指针做指针运算**。而你又想：

1. 把指针转换为整数 → 做偏移计算
2. 偏移完再转回来继续使用

```go
*int → unsafe.Pointer → uintptr → 计算偏移 → uintptr → unsafe.Pointer → *int
```

例子：

```go
package main

import (
    "fmt"
    "unsafe"
)

func main() {
    arr := [3]int{10, 20, 30}

    // 获取第一个元素的指针
    p0 := unsafe.Pointer(&arr[0])
    
    // 通过 uintptr 偏移指针
    p1 := uintptr(p0) + unsafe.Sizeof(arr[0]) // 加一个 int 大小 → 到 arr[1]
    
    // 再转回 unsafe.Pointer → *int
    p1Ptr := (*int)(unsafe.Pointer(p1))

    fmt.Println("第二个元素是：", *p1Ptr) // 输出：20
}

```

**一句话总结：**

`unsafe.Pointer` 是类型之间转换的桥梁，`uintptr` 是做地址偏移的工具。前者保引用，后者参与运算，两个常常一起用！

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            																									

### 28.什么是Goroutine

| **定义**     | goroutine 是 Go 中由 runtime 管理的轻量级线程。              |
| ------------ | ------------------------------------------------------------ |
| **启动方式** | 使用 `go 函数名(参数)` 启动一个新的并发任务。                |
| **优势**     | - 创建/销毁开销小（初始栈仅约 2KB） - 可同时运行成千上万个 - 自动调度和伸缩 |
| **调度模型** | 使用 **GMP 模型**： G（任务） P（调度器） M（内核线程）      |
| **通信方式** | 使用 `channel` 进行 goroutine 之间通信，保证同步与数据安全。 |
| **应用场景** | - 高并发请求处理（如 Web 服务） - 并发爬虫 - 并行计算 - 网络连接管理等 |
| **注意事项** | - 主程序退出，所有 goroutine 会被强制关闭 - 可使用 `WaitGroup` 控制同步退出 |

- goroutine ≠ 系统线程，是更轻便、可调度的逻辑线程。
- goroutine 不支持直接操作系统级别的线程 API。
- 通过 `runtime.GOMAXPROCS(n)` 可以设置最大并发线程数（一般默认=CPU核数）



### 29.slice相关

#### 数组和切片的异同

**相同点：**

1. 都只能存储**相同类型的数据**
2. 都可以通过下标 `arr[i]` 来访问元素
3. 都可以通过 `len()` 获取长度，`cap()` 获取容量

 **不同点：**

| 项目         | 数组（Array）              | 切片（Slice）                                    |
| ------------ | -------------------------- | ------------------------------------------------ |
| **长度**     | 固定长度，定义时就确定     | 可变长度，支持自动扩容                           |
| **类型**     | 值类型，赋值会复制整个数组 | 引用类型，指向底层数组，多个切片可能共享底层数据 |
| **传参行为** | 值传递（复制整个数组）     | 值传递（复制切片结构体，依然引用同一底层数组）   |
| **内存结构** | 直接存放数据               | 包含指针、长度、容量，数据在底层数组中           |
| **扩容行为** | 不支持                     | 自动扩容，扩容后会指向新的底层数组               |

> **[3]int 和 [4]int 是同一个类型吗？**
>
> **不是！**
> Go 中数组的长度是类型的一部分，`[3]int` 和 `[4]int` 属于**完全不同的类型**，不能互相赋值！

**一句话总结：**

数组是定长、值类型，不能自动扩容；切片是引用类型，长度可变、支持扩容。数组在赋值或传参时会复制整个数组，而切片只是复制结构体，底层数据共享



#### 切片的底层类型和一些特性：

**底层类型：**

- 每个切片都指向一个底层数组
- 每个切片都保存了当前切片的长度、底层数组可用容量

```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```

**特性：**

- 使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片

- 使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片

- 通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而已

- 我们通过copy()实现复制一个新的切片

  ```go
  newSlice := make([]int, len(oldSlice))
  copy(newSlice, oldSlice)
  
  ```

- **扩容机制：** 

  ​       正常 append（不扩容）

  - 如果 `cap >= len + 新元素数`，直接在底层数组追加元素；

  - `len++`，返回原 slice。

    扩容触发（底层容量不足）

  - 系统会 **分配新数组**（新容量更大）；

  - 将旧数据拷贝到新数组中；

  - 返回一个 **新的 slice**，原 slice 不变

>  **总结口诀版：**
>
> 🌟「Slice 是引用，底层是数组，扩容需谨慎，内外看指针」
> 🔍「未扩容，共用底层数组，改了都变；一旦扩容，指向新内存，外部不变」



#### **切片作为参数传递：**

##### **内部append，外部有时修改，有时不修改？**

> 扩容后，返回新的slice底层数组

```go
//当传入的切片，在函数内发送扩容：
func modify(s []int) {
	s = append(s, 4) // 如果扩容了，s 变成新数组
	s[0] = 100       // 修改的是新的底层数组
}

func main() {
	s := []int{1, 2, 3}
	modify(s)
	fmt.Println(s)  // 输出仍是 [1 2 3]，外部未变
}

```

🍃 情况1：未扩容（外部和内部，底层相同）

- 函数中对 slice 的元素修改（如 `s[0] = 99`），会直接影响外部；
- 因为 **slice 是引用底层数组的**，传入函数只是复制了一个结构体，指向同一块内存。

🧩 情况2：发生扩容（外部和内部，底层不同）

- 函数中 `append()` 导致扩容，返回的新 slice 会指向新的底层数组；
- 此时函数中的 slice 和外部 slice 指向的数组已经不同，**外部不会受影响**。



##### 切片传参时 怎么避免/直接 影响外部？

方案1：**复制一份新切片(不影响外部)**

```go
newSlice := make([]int, len(oldSlice))
copy(newSlice, oldSlice)
```

这样就不会共享底层数据，函数里怎么改都不影响外部啦 ✨

方案2：**使用指针传递明确要修改**

```go
func modify(s *[]int) { //参数为：*[]int 明确修改外部
    (*s)[0] = 999
}
```

显式地通过指针来传递 intent：“我就是要改原来的数据”，适用于需要让外部变化的情况。

> ##### 数组作为返回值的问题
>
> 因为数组是值类型，函数返回的是一个复制品，适合数据量小、性能要求不高的情形：
>
> ```go
> func makeArray() [3]int {
>     return [3]int{1, 2, 3}
> }
> ```
>
> **但如果数组很大，或者希望多个地方共享内存，通常就改用切片**

🌟 总结口诀

> ✅「数组、切片都是值传递，切片共享底层很灵异」
> ✅「函数修改数组无影响，切片改值要注意」
> ✅「怕影响就 copy，新切片来处理」
> ✅「想修改就指针，修改原始无疑虑」



#### 数组中取slice

**当你从数组取一个等长的 slice，**

```go
arr := [5]int{1, 2, 3, 4, 5}
s := arr[:] // 或 arr[0:5]
```

此时：不会复制数组内容 

**只是新建了一个 `slice` 结构体，指向 `arr` 的首地址** 

```go
原始数组：        [1, 2, 3, 4, 5]
地址：             ^ (arr[0] 的地址)
切片：           ┌─────────────┐
                 │ ptr = arr[0]│
                 │ len = 5     │
                 │ cap = 5     │
                 └─────────────┘
```

✅ 所以 `s` 和 `arr` 共享同一段内存，改 `s[0]` 就等于改 `arr[0]`。

**陷阱：**扩容后，底层数组不在是arr

```go
arr := [3]int{1, 2, 3}
s := arr[:]

s = append(s, 4) // ⚠️ 超出了容量，触发扩容
s[0] = 100
fmt.Println(arr) // 输出：[1 2 3]，并没有变
```

**使用场景：**

| 场景                           | 建议                                     |
| ------------------------------ | ---------------------------------------- |
| 需要快速处理原数组的一部分数据 | ✅ 用切片（高效，不拷贝）                 |
| 不希望原数组被影响             | ❌ 需要 copy 一份数据                     |
| 不需要扩容，纯读写操作         | ✅ 安全共享底层                           |
| 切片会 append 并可能扩容       | ⚠️ 注意扩容时会新建底层数组，原数组不会变 |



#### 扩容机制

**1.18之前：**

| 原容量大小    | 扩容倍数规则            |
| ------------- | ----------------------- |
| 小于 1024     | 容量 × 2（指数级增长）  |
| 大于等于 1024 | 容量 × 1.25（线性增长） |

**1.18之后：**

![image-20250409112231574](./assets/image-20250409112231574.png)

| oldcap | 扩容系数 |
| ------ | -------- |
| 256    | 2.0      |
| 512    | 1.63     |
| 1024   | 1.44     |
| 2048   | 1.35     |
| 4096   | 1.30     |



