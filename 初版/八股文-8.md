# 八股文-8

## 内存相关

### 1.内存分配原理

> 这一部分主讲数据结构，流程主要在6.

#### 堆

Go 为了实现高性能、并发友好的内存管理，在底层设计了分层的内存分配架构，包括：

> spans及arena负责内存分配，bitmap负责GC

![image-20250503170448732](./assets/image-20250503170448732.png)

- **arena**：即“堆区”，程序运行时向操作系统申请一大块空间（默认 512GB）；
- **span**：基本的内存管理单元，是页（page）的集合；
- **mcache（线程私有）**：缓存各个 class 对象用的 span，避免频繁加锁；
- **mcentral（全局共享）**：管理所有 class 的 span，对接 mcache 和堆；
- **heap**：真正向操作系统申请内存的地方，central 不够用时向 heap 要。

****

1️⃣ arena（堆区）

- 大小：512GB（64 位系统）
- 划分：按 8KB 为单位划分为 page（页），共约 67M 个页
- 管理工具：
  - **spans**：记录页的使用信息（每页一个指针，大小 512MB）
  - **bitmap**：用于 GC 追踪对象指针的位图

------

2️⃣ span（页的集合）

![image-20250503172632379](./assets/image-20250503172632379.png)

- span 是由 1 个或多个连续 page 组成的内存块
- 每个 span 会根据对象大小进行再次划分，形成小块（block）
- 每个 span 结构体包含：
  - `startAddr`：起始地址
  - `npages`：页数
  - `nelems`：可分配块数量
  - **`allocBits`：是否被分配的位图**
  - **`gcmarkBits`：是否被引用的位图**
  - `spanclass`：标识其属于哪个 class（0~66）
  - `elemsize`：每个对象的大小（由 class 表决定）
  - `allocCount`：已分配块数量
- **小对象（≤ 32KB）由 mspan 管理；大对象（> 32KB）mheap单独管理，class ID 为 0**

****

3️⃣ mcache（每线程私有）

![image-20250503171452383](./assets/image-20250503171452383.png)

- 是每个线程的 span 缓存层
- 避免每次申请内存都加锁，提高并发性能
- 包含：
  - `alloc [67*2]*mspan`：两个 class 组（scan、noscan），每种各 67 个 class
- 如果线程要分配一个对象，就从 mcache 中取对应 class 的 span

------

4️⃣ mcentral（全局共享）

- 每个 class 对应一个 mcentral，集中管理该类 span
- 当线程的 mcache 缓存不足，就从 mcentral 获取 span
- 结构包括：
  - `nonempty`：有空闲块的 span 链表
  - `empty`：已满的 span 链表
  - `nmalloc`：统计信息
  - `lock`：全局锁，防止多线程竞争

🌟 分配和释放的流程：

- 获取 span：
  1. 加锁
  2. 从 nonempty 中取一个 span
  3. 移入 empty（防止重复取用）
  4. 解锁
- 归还 span：
  1. 加锁
  2. 从 empty 移除
  3. 加入 nonempty
  4. 解锁

------

5️⃣ heap（堆）

![image-20250503171433419](./assets/image-20250503171433419.png)

- 当 mcentral 缺少 span，会向 heap 请求新内存页
- 系统预分配的内存分为spans、bitmap、arean三个区域，通过mheap管理起来。

#####  **内存分配过程**

**小对象：**

> 大对象mheap直接分配

以申请size为n的内存为例，分配步骤如下：

1. 获取当前线程的私有缓存mcache
2. 根据size计算出适合的class的ID
3. 从mcache的alloc[class]链表中查询可用的span
4. 如果mcache没有可用的span则从mcentral申请一个新的span加入mcache中
5. 如果mcentral中也没有可用的span则从mheap中申请一个新的span加入mcentral
6. 从该span中获取到空闲对象地址并返回

------

🧾 总结：一张层级结构图梳理（文字版）

```
        ┌────────────────────────┐
        │        操作系统        │
        └────────┬───────────────┘
                 │
        ┌────────▼──────────────┐
        │        Heap           │（实际申请内存 + GC）
        └────────┬──────────────┘
                 │
        ┌────────▼──────────────┐
        │      mcentral         │（全局 span 池）
        └────────┬──────────────┘
                 │
        ┌────────▼──────────────┐
        │      mcache（每线程） │（快速分配）
        └────────┬──────────────┘
                 │
        ┌────────▼──────────────┐
        │        span           │（管理 page）
        └────────┬──────────────┘
                 │
        ┌────────▼──────────────┐
        │       arena           │（512GB 主体区域）
        └────────────────────────┘
```

#### 栈

**分配**

- **每个 goroutine 创建时，都会分配一个初始栈空间**，从 Go 1.17 开始是 2KB。

  > **若变量从栈逃逸到堆上，那是单独通过 `mheap` → span 分配的新内存，不影响栈本身。**
  >
  > 这个栈不是直接从操作系统申请的，而是**从 Go runtime 管理的一大块内存（mheap 中的 spans）中分配。**

------

 **栈内存的来源**

-  栈内存是独立分配的一块连续内存，并不在 `arena` 区域中；
-  它不使用 `span` 管理，也不由 `mheap` 负责；
-  它由运行时在创建 goroutine 时独立分配，并且随 goroutine 销毁时自动释放；

------

 补充图解（简略）

```
         +--------------------+
堆（heap）| spans + bitmap + arena（mheap）
          +--------------------+

          +--------------------+
栈（stack）| goroutine 独立栈 -> stackalloc -> spans（mheap）------如果逃逸到堆上
          +--------------------+
          
+--------------------------+
|        操作系统内存       |
+--------------------------+
|         heap (堆)        | <- mheap 管理，arena + span + bitmap
|                          |
+--------------------------+
|     goroutine stack1     | <- 独立内存区域，非 arena/span -------- 不逃逸到堆上
+--------------------------+
|     goroutine stack2     |
+--------------------------+
```





### 2.垃圾回收原理

> 之前描述了，Golang GC 三色标记清除法的详细流程，这里主要讲原理：内存上如何实现标记的

span中维护了一个个内存块，并由一个位图allocBits表示每个内存块的分配情况。在span数据结构中还有另一个位图gcmarkBits用于标记内存块被引用情况。

![image-20250503172825231](./assets/image-20250503172825231.png)

- `allocBits`：这块内存**有没有被分配**。
- `gcmarkBits`：这块内存**有没有被引用**。
- 回收：`allocBits == 1 && gcmarkBits == 0`：这块内存**曾用过但现在没人用了**，可以回收！
- 回收后：把 `allocBits = gcmarkBits`，原来的分配状态被新的“引用状态”替代，更高效



### 3.逃逸分析

什么是逃逸分析？

逃逸分析是 Go 编译器在**编译阶段**进行的一种优化分析，目的在于：

> **判断一个变量是应该分配在栈上还是堆上。**

- **分配在栈上：** 生命周期受函数控制，函数结束自动回收；
- **分配在堆上：** 被函数外引用，交给 GC 管理。

------

逃逸策略:

| 情况                             | 分配位置   |
| -------------------------------- | ---------- |
| 函数外无引用，且对象小           | 栈         |
| 函数外有引用（如:返回指针）      | 堆（必定） |
| 对象太大，栈空间不够             | 堆（自动） |
| 类型无法静态判断（如 interface） | 堆（保守） |
| 被闭包引用的局部变量             | 堆         |

------

逃逸分析典型场景

 3.1 指针逃逸

```
func StudentRegister(name string, age int) *Student {
    s := Student{} // 逃逸
    s.Name = name
    s.Age = age
    return &s
}
```

**只要这个值没有在函数外部被引用为地址（即没有逃逸），编译器就会分配在栈上。**

> 为什么分配到栈上，外部返回的变量仍不为空值？Golang函数的返回均为值拷贝，会创建一块新内存给返回值。

输出提示：

```
main.go:9: new(Student) escapes to heap
```

------

3.2 栈空间不足导致逃逸

```
s := make([]int, 10000)
```

- `1000` 元素 → 不逃逸；
- `10000` 元素 → 逃逸（栈放不下）。

栈空间默认较小（约 1~2MB），太大时会自动转堆。

------

3.3 动态类型（interface）逃逸

```go
s := "Escape"
fmt.Println(s)
```

因为 `fmt.Println(a ...interface{})` 参数为接口类型，编译器**难以推断实际类型**，保守处理，导致逃逸：

```
main.go:7: s escapes to heap
```

------

**3.4 闭包引用逃逸**

```go
func Fibonacci() func() int {
    a, b := 0, 1
    return func() int {
        a, b = b, a+b
        return a
    }
}
```

闭包返回后，`a` 和 `b` 虽然原是局部变量，但闭包中被引用，生命周期延长 → **逃逸到堆上**：

```
main.go:6: moved to heap: a
main.go:6: moved to heap: b
```



### 4. Go 中的内存泄漏

> Go 中内存泄漏多因 goroutine 泄漏，常见是 chan 阻塞、Ticker 未 stop、切片/字符串截取造成底层数据未释放。定位上用 `pprof` 的 heap、goroutine、allocs profile，关注 goroutine 栈帧重复和对象 inuse 增长，多配合 trace 工具分析调度。防止泄漏的关键是：**合理资源释放 + 控制 goroutine 生命周期 + 减少隐式引用**。

一、什么是内存泄漏？

Go 中的“内存泄漏”本质是：**一段内存不再使用，但仍然被引用，无法被 GC 回收**。

------

二、常见泄漏场景（总结 + 案例）

| 场景编号              | 描述                             | 示例                               |
| --------------------- | -------------------------------- | ---------------------------------- |
| ① goroutine 泄漏      | 未关闭、阻塞、无限等待（最常见） | `select{}` 无出口；chan 读写无配对 |
| ② 资源未释放          | 如 mutex 死锁、Ticker 未 stop    | `defer ticker.Stop()` 缺失         |
| ③ 切片截取            | 子切片引用整个底层数组，阻止回收 | `s1 := s0[:3]` 后未置空 s0         |
| ④ 字符串截取          | 同切片，底层数组被持续引用       | `str1 := str0[:10]`                |
| ⑤ 大数组参数传值      | 复制大块内存，引发瞬时泄漏       | `func f(arr [1e6]int)` 被频繁调用  |
| ⑥ map 中元素引用      | 元素引用外部数据导致数据未被释放 | map value 是闭包或大 struct 指针   |
| ⑦ 全局变量 / 缓存未清 | 缓存未定期清理，内存持续增长     | `sync.Map` 或 `map` 逃逸           |

------

三、内存泄漏排查方法（用 pprof）

可以通过 `net/http/pprof` 和 `go tool pprof` 配合进行排查：

| 工具                | 关键指标                        | 含义                    |
| ------------------- | ------------------------------- | ----------------------- |
| `heap` profile      | `inuse_space` / `inuse_objects` | 当前占用的内存 / 对象数 |
| `goroutine` profile | goroutine 数量是否飙升          | 检查是否泄漏或阻塞      |
| `allocs` profile    | 累计分配内存情况                | 是否频繁创建大对象      |
| `trace`             | 各 goroutine 的调度与调用路径   | 观察是否有栈阻塞        |



### 5.什么情况下会发生内存逃逸？（必问）

> **“只要变量的生命周期超出了当前函数作用域，Go 编译器就会安排它逃逸到堆上”**。

| 场景                    | 说明                                                        |
| ----------------------- | ----------------------------------------------------------- |
| 1️⃣ 返回局部变量的指针    | `return &x`，`x` 是局部变量，函数返回后还要使用             |
| 2️⃣ 变量被闭包引用        | 闭包中捕获了外部变量，生命周期被延长                        |
| 3️⃣ 向 channel 中发送指针 | 指针逃逸给其他 goroutine                                    |
| 4️⃣ interface 包含值      | interface{} 是**动态类型**，需要保存值的副本，有时会逃逸    |
| 5️⃣ slice / map 存储指针  | 容器内部可能将指针值暴露给外部                              |
| 6️⃣ slice 扩容太大        | 新 slice 可能被放到堆上（不是逃逸，是 heap 分配，但容易混） |



### 6.Go 是如何分配内存的？

1. **初始化分配区域：`mheap` 管理全局堆内存**

- 程序启动时，Go 会向操作系统申请一大块内存空间，称为 **arena 区域**。
- arena 区域被划分为 **页（page）**，默认大小为 **8KB**。
- 页由 **span** 管理，一个 span 是一组连续的页。

------

2. **基础结构：Span / Bitmap / Arena**

| 结构       | 说明                                                    |
| ---------- | ------------------------------------------------------- |
| **Span**   | 管理一组页，可用于分配某一类大小的对象（例如 16B、32B） |
| **Arena**  | 操作系统提供的大块内存区域，由 mheap 管理               |
| **Bitmap** | 用于标记 arena 中哪些地址处于使用状态，为 GC 提供支持   |

------

3. **分级管理内存：`mcentral` + `mcache`**

- **`mcentral`**：按对象大小分类，管理多个 span，是全局结构。
- **`mcache`**：每个 P（即调度器 Processor）一个，是线程私有缓存，从 `mcentral` 获取 span，提高局部性和性能。

> 🎯 所以：小对象（≤32KB）由 `mcache` 快速分配，大对象直接向 `mheap` 请求。

------

4. **内存申请流程概览（小对象）：**

```
Goroutine → mcache → mcentral → mheap → 系统内存
```

1. 优先从 `mcache` 分配。
2. `mcache` 不够，则向 `mcentral` 请求 span。
3. `mcentral` 没有空 span，则向 `mheap` 申请新 span。
4. 若 `mheap` 内存耗尽，则向操作系统申请新的内存。

------

5. **对于栈内存呢？**

- 栈内存不在 `mheap` 管理范围内。
- 每个 goroutine 初始化时分配一个 2KB 的栈，按需增长。
- 栈是连续空间，能快速分配和释放，无需 GC 介入。
- 如果变量发生逃逸（如返回局部指针），会从栈转移到堆上。



### 7.Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？

**Channel 分配在堆上**

是的，**`channel` 总是分配在堆上**，原因主要有两个：

1. **生命周期较长**：`channel` 通常跨多个 goroutine 使用，不可能局限于一个函数调用的栈帧；
2. **逃逸分析结果**：由于会被 goroutine 间引用，Go 编译器在逃逸分析时会判定它逃逸到了堆上。

------

**哪些对象分配在栈上？哪些分配在堆上？**

Go 的变量分配位置由编译器根据**逃逸分析**决定，大致遵循以下规则：

| 情况                                    | 分配位置 | 原因                                       |
| --------------------------------------- | -------- | ------------------------------------------ |
| 局部变量，不被外部引用                  | 栈       | 生命周期仅在函数内，编译器可以安全管理     |
| 返回局部变量指针                        | 堆       | 函数退出后仍可能被使用，栈无法保存         |
| 闭包引用外部变量                        | 堆       | 被闭包长期持有，不能跟随栈回收             |
| 发送指针到 channel、存入 map、slice 等  | 堆       | 无法保证变量不会被函数外访问               |
| interface 类型变量（具体类型未知）      | 堆       | 需要在运行时处理，不确定内存布局           |
| 大对象（比如大数组）                    | 堆       | 避免栈爆，栈空间一般比较小                 |
| **goroutine、channel、map、slice 本体** | **堆**   | **生命周期不确定，一般作为长生命周期组件** |



### 8.介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？

 一、大对象与小对象的划分

在 Go 的内存管理中，**32KB 是划分小对象和大对象的分水岭**：

| 对象类型 | 大小判断 | 分配方式                         |
| -------- | -------- | -------------------------------- |
| 小对象   | ≤ 32KB   | 通过 `mcache → mcentral → mspan` |
| 大对象   | > 32KB   | 直接从 `mheap` 分配              |

> 这个 32KB 的门槛来自于 Go 的 runtime 实现（固定值），大对象会走更慢的路径。

------

二、为什么“小对象多”会造成 GC 压力？

这其实和 **GC 的算法** ——**三色标记法（tri-color marking）** 紧密相关。

1. **GC 是以对象为单位遍历的**：小对象多就意味着**对象数量多**（哪怕总内存用得不高）；
2. **三色标记法**在 GC 的标记阶段，需要遍历对象图并染色每一个对象；
3. 对象越多、指针越多，GC 要做的工作越多，尤其在并发场景下容易**卡顿**；
4. 小对象生命周期一般短，**分配 → 回收很快**，但频繁触发 GC 是很大的 CPU 消耗；

> 🌪️ 举个通俗的例子：你花 100 元买 1 个大西瓜和 100 个小李子，总价一样，但清点李子比看一个西瓜要累多了！



## 编译
