# 八股文-5

## channel相关

### 1.**channel 是否线程安全？锁用在什么地方？**

- channel 是线程安全的，因为底层用锁保证 send/recv 是原子操作；

  > - 多个 goroutine 可以安全地并发向同一个 channel 写数据；
  > - 多个 goroutine 也可以安全地并发从同一个 channel 读数据；
  > - **不需要额外加锁**。
  >
  > > 👉 所以你在并发模型里看到大量场景直接用 channel 传递数据，而没有显式加锁。

- 锁主要保护 channel 的内部状态，如队列、等待队列、缓冲区；

  > **发送 & 接收时涉及调度，使用了互斥锁（`lock`）来保证数据结构不被并发破坏。**

  

实际开发中通常是**“用 channel 做通信，用锁保护共享资源”**；

**channel 更适合 goroutine 间消息同步，锁更适合对共享数据做复杂读写**。



### 2.go channel 的底层实现原理 （数据结构）

```go
type hchan struct {
    qcount    uint           // 当前缓冲区中元素数量
    dataqsiz  uint           // 缓冲区容量（buf 的长度）
    buf       unsafe.Pointer // 环形队列缓冲区（存放元素）
    elemsize  uint16         // 每个元素的大小（字节）
    elemtype  *_type         // 元素的类型信息
    sendx     uint           // 下一个写入元素的位置（循环索引）
    recvx     uint           // 下一个读取元素的位置（循环索引）

    recvq     waitq          // 接收 goroutine 等待队列（recv 被阻塞）
    sendq     waitq          // 发送 goroutine 等待队列（send 被阻塞）

    closed    uint32         // channel 是否关闭
    lock      mutex          // 操作锁，保护 channel 的并发安全
}
```

![](https://cdn.nlark.com/yuque/0/2022/webp/22219483/1661787750459-2608e3a8-f5f9-4d1c-a97f-314d4d83fecf.webp#averageHue=%23f5eadb&clientId=uef4c3b7a-0bed-4&errorMessage=unknown%20error&from=paste&id=ud2b2cad6&originHeight=906&originWidth=1266&originalType=url&ratio=1&rotation=0&showTitle=false&status=error&style=none&taskId=u23754328-a657-4b43-9730-5a80293ced0&title=)

Go 中的 channel 底层用一个结构体 `hchan` 实现，核心包括：

- 一个缓冲区 `buf`（如果是有缓冲的话），用作环形队列；

- 两个下标 `sendx`/`recvx` 用于追踪写入/读取的位置；

- 两个等待队列 `sendq`/`recvq`，存放被阻塞的发送者/接收者；

  - ### **sudog 和 waitq 是什么？**

    - `waitq` 是一个双向链表，存放的是 `*sudog` 指针；**(waitq 存储所有阻塞的go程指针)**
    - `sudog` 是对 goroutine 的封装结构，里面包含 goroutine 地址、要收/发的元素地址等信息；
    - 当 goroutine 被阻塞时，实际是挂在 `sendq` 或 `recvq` 的链表上，等待调度器唤醒。

- 一个互斥锁 `lock` 用于保护并发操作的安全；

#### 有缓冲 VS 无缓冲 channel

- **无缓冲 channel：**
  - `dataqsiz = 0`，也就是 `buf` 为 nil；
  - **send 必须等待 recv，同步通信；**
  - 数据不会“存储”，只能“直接传递”。
  - **无缓存channel适用于数据要求同步的场景**
- **有缓冲 channel：**
  - `dataqsiz > 0`，buf 是环形队列；
  - **send/recv 是异步的，只要 buf 未满/未空就可以操作；**
  - 用 `sendx`/`recvx` 来维护循环数组的位置。
  - **有缓存channel适用于无数据同步的场景。**



### 3.nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？（各类变种题型，重要）

+ 给一个 nil channel 发送数据，造成永远阻塞
+ 从一个 nil channel 接收数据，造成永远阻塞
+ 给一个已经关闭的 channel 发送数据，引起 panic
+ 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值
+ 无缓冲的channel是同步的，而有缓冲的channel是非同步的

以上5个特性是死东西，也可以通过口诀来记忆：“空读写阻塞，写关闭异常，读关闭空零”。



### 4.**向 channel 发送数据和从 channel 读数据的流程是什么样的？**

> 发送和接收：先看是否有等发送/接收待go程，再看缓冲区是否为空，最后：一般情况

#### 发送流程：

首先尝试从 `recvq` 读等待队列中找接收者**（先看是否有等待接收的go程）**

- 如果有等待接收的 goroutine（说明是**无缓冲通道**或**缓冲区为空**），就：
  - 直接把数据从发送者复制到接收者指定的内存地址
  - **把接收者从队列中移除并唤醒**
  - **发送成功，退出**

**(再看缓存区)**

 如果缓冲区还有空位（`qcount < dataqsiz`）

- 把数据复制到缓冲区中 `sendx` 位置
- `sendx = (sendx + 1) % dataqsiz`（环形数组移动）
- `qcount++`
- **发送成功，退出**

如果缓冲区满了

- 创建一个 `sudog` 包装当前 goroutine 和待发送数据
- 把当前 goroutine 放入 `sendq` 发送等待队列
- **进入睡眠（等待被接收者唤醒）**

![](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661788117541-f82a3d7e-8b22-46cd-9bd9-dde26f0d290c.png#averageHue=%23323232&clientId=uef4c3b7a-0bed-4&errorMessage=unknown%20error&from=paste&id=uc645cac1&originHeight=569&originWidth=488&originalType=url&ratio=1&rotation=0&showTitle=false&size=35907&status=error&style=none&taskId=u6802c438-331a-4483-b841-ea9876571eb&title=)

#### 接收流程：

 如果 `sendq` 不为空**（先看是否有等待发送而阻塞的go程）**

- 对于无缓冲 channel：**（直接操作sendq）**
  - 从 `sendq` 中取出一个发送者 `sudog`
  - 从其保存的数据中读取值
  - **唤醒发送者 goroutine**
- 对于有缓冲 channel：**（说明：buf满了）**
  - 从缓冲区中读取数据（`recvx`）
  - 同时从 `sendq` 里取出发送者，把数据写入缓冲区尾部（`sendx`）
  - 移动 `recvx` 和 `sendx`
  - 唤醒发送者

 如果缓冲区中有数据（`qcount > 0`）

- 从 `recvx` 位置取出数据
- `recvx = (recvx + 1) % dataqsiz`
- `qcount--`
- **读取成功，退出**

如果缓冲区也没有数据

- 创建一个 `sudog`，加入 `recvq` 等待队列
- **当前 goroutine 睡眠，等待被发送唤醒**

![](https://cdn.nlark.com/yuque/0/2022/png/22219483/1661788153163-c386fedf-84b2-42ed-9965-d5d80743650c.png#averageHue=%232c2c2c&clientId=uef4c3b7a-0bed-4&errorMessage=unknown%20error&from=paste&id=u74003dc2&originHeight=744&originWidth=608&originalType=url&ratio=1&rotation=0&showTitle=false&size=52767&status=error&style=none&taskId=u4efb3973-b0e4-48cf-a58a-9e7f57847cf&title=)

#### 关闭channel：

关闭操作是个“广播式唤醒”，会影响所有相关 goroutine：

- 标记 `closed = 1`
- 遍历 `recvq` 中所有 `sudog`，唤醒它们（返回零值）
- 遍历 `sendq` 中所有 `sudog`，唤醒它们，同时抛出 panic（因为关闭的 channel 不允许发送）



### 5.channel 在什么情况下会引起资源泄漏

> Channel 可能会引发 goroutine （永久阻塞）泄漏，不可能是内存泄漏。
>
> - 二个情况
>   - 没有发生/接收者
>   - 没有关闭channel

1. **channel 无人接收 / 无人发送导致 goroutine 阻塞**

- **发送阻塞场景**：

  ```go
  ch := make(chan int)
  go func() {
      ch <- 1  // 没有人接收，阻塞！
  }()
  ```

- **接收阻塞场景**：

  ```go
  ch := make(chan int)
  go func() {
      <-ch  // 没有人发送，阻塞！
  }()
  ```

只要没人配合发送/接收，对应的 goroutine 就会卡死在 `sendq` 或 `recvq`，永远不会退出。

------

2. **for-select 模式下，channel 永远无法选中**

```go
ch := make(chan int)
go func() {
    for {
        select {
        case data := <-ch:
            fmt.Println(data)
        }
        // 没有 default，也没有任何发送者！
    }
}()
```

这个 goroutine 会永久阻塞在 select 上，不会被唤醒。

------

3. **channel 没有关闭，range 无法退出**

```go
func readAll(ch chan int) {
    for val := range ch {  // 如果 ch 永不关闭，这个 goroutine 永远在读
        fmt.Println(val)
    }
}
```

如果忘记 `close(ch)`，range 永远等不到结束信号，就会泄漏。

------

4. **channel 作为信号通知，结果没人监听了**

```go
done := make(chan struct{})
go func() {
    <-done // 如果主逻辑忘了 close(done)，这里就泄漏了
}()
```

------

#### Channel 不会引起 **内存泄漏**

- 如果一个 channel 不再被任何变量引用，GC 会自动清理掉（包括内部 `buf`, `sendq`, `recvq` 等），不会造成内存泄漏。
- **但 goroutine 泄漏是逻辑层面的泄漏，不依赖 GC 判断引用关系**。